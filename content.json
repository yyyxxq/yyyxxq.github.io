{"pages":[{"title":"“categories”","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"mit6.S081 lab3","text":"Lab: page tables Print a page table (easy) 任务描述 在第一个进程结束的时候，打印页表。 需要实现一个vmprint()函数来实现打印页表。 12345678910page table 0x0000000087f6e000..0: pte 0x0000000021fda801 pa 0x0000000087f6a000.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 原理解析 PTE:page table entries(页表指向) VA:virtual address(虚拟地址) PA:Physical address(真实地址) 指向硬件内存的64位整数 Pagetable(页表) 页表本身是一个PA。 它是一个指针，指向一个大小固定为4kb的内存块的开头。 页表内可以存储真正的数据，也可以存储页表。 页表是64位整数，所以一页内存可以存下512个页表。 从VA映射到PA的流程 每个进程有一个专属的proc结构 里面有进程专属的pagetable VA映射到PA要经过三次转化。 VA中的index有27位，分三段来指向页表。 页表指向真是内存的结构分成了三层。 VA-&gt;proc pagetable-&gt;L2 pagetable-&gt;L1 pagetblae-&gt;L0 pageable-&gt;PA 样例解析 123456789… 0：… … 0：… … … 0：标志位0x1f，用户可以访问… … … 1：标志位0x0f，用户不可以访问… … … 2：标志位0x1f，用户可以访问… 255：… … 511：… … … 510：标志位0x07,可读写… … … 511：标志位0x0b，可执行可读 实操 在defs.h中加入 1void vmprint(pagetable_t); 在vm.c中加入 123456789101112131415void vmprintlevel(pagetable_t x,int level)&#123; for(int i=0;i&lt;512;i++)&#123; pte_t pte=x[i]; pagetable_t child=(pagetable_t)PTE2PA(pte); if((pte&amp;PTE_V)==0)continue; for(int i=0;i&lt;level;i++)printf(\".. \"); printf(\"..%d: pte %p pa %p\\n\",i,pte,child); if((pte&amp;(PTE_W|PTE_R|PTE_X))==0)vmprintlevel(child,level+1); &#125;&#125;void vmprint(pagetable_t x)&#123; printf(\"page table %p\\n\",x); vmprintlevel(x,0);&#125; A kernel page table per process (hard) 任务描述 往每个进程中复制一份内核页表 任务步骤 1.在kernel/proc.h为truct proc加入内核页表。 1pagetable_t krnl_pagetable; 2.kernel/vm.c中vmkinit是为最开始的全局kernel_pagetable创建初始化的，将其修改为可对某个页表进行初始化的函数。CLINT只会在开始是被加载，所以单独在procinit函数里进行初始化。同时修改kvmmap和kvmpa的传参。并且修改对应的函数使用的传参。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidkvmmap(pagetable_t now_pagetable,uint64 va, uint64 pa, uint64 sz, int perm)&#123; if(mappages(now_pagetable, va, sz, pa, perm) != 0) panic(\"kvmmap\");&#125;void auto_kvmmap(pagetable_t now_pagetable)&#123; // uart registers kvmmap(now_pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(now_pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // CLINT// kvmmap(now_pagetable,CLINT, CLINT, 0x10000, PTE_R | PTE_W); // PLIC kvmmap(now_pagetable,PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(now_pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we'll make use of. kvmmap(now_pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(now_pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);&#125;voidkvminit()&#123; kernel_pagetable = (pagetable_t) kalloc(); memset(kernel_pagetable, 0, PGSIZE); kvmmap(kernel_pagetable,CLINT, CLINT, 0x10000, PTE_R | PTE_W); auto_kvmmap(kernel_pagetable);&#125;uint64kvmpa(uint64 va,pagetable_t now_pagetable)&#123; uint64 off = va % PGSIZE; pte_t *pte; uint64 pa; pte = walk(now_pagetable, va, 0); if(pte == 0) panic(\"kvmpa\"); if((*pte &amp; PTE_V) == 0) panic(\"kvmpa\"); pa = PTE2PA(*pte); return pa+off;&#125; 3.修改kernel/proc.h中procinit里内核栈空间的分配，将其改到allocproc里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768voidprocinit(void)&#123; struct proc *p; initlock(&amp;pid_lock, \"nextpid\"); for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; initlock(&amp;p-&gt;lock, \"proc\"); // Allocate a page for the process's kernel stack. // Map it high in memory, followed by an invalid // guard page./* char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); uint64 va = KSTACK((int) (p - proc)); kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-&gt;kstack = va;*/ &#125;// kvminithart();&#125;static struct proc*allocproc(void)&#123; struct proc *p; for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; acquire(&amp;p-&gt;lock); if(p-&gt;state == UNUSED) &#123; goto found; &#125; else &#123; release(&amp;p-&gt;lock); &#125; &#125; return 0;found: p-&gt;krnl_pagetable = (pagetable_t) kalloc(); memset(p-&gt;krnl_pagetable,0,PGSIZE); auto_kvmmap(p-&gt;krnl_pagetable); char *pa = kalloc(); if(pa == 0)panic(\"kalloc\"); uint64 va = KSTACK((int) (p - proc)); kvmmap(p-&gt;krnl_pagetable,va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-&gt;kstack = va; p-&gt;pid = allocpid(); // Allocate a trapframe page. if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0)&#123; release(&amp;p-&gt;lock); return 0; &#125; // An empty user page table. p-&gt;pagetable = proc_pagetable(p); if(p-&gt;pagetable == 0)&#123; freeproc(p); release(&amp;p-&gt;lock); return 0; &#125; // Set up new context to start executing at forkret, // which returns to user space. memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context)); p-&gt;context.ra = (uint64)forkret; p-&gt;context.sp = p-&gt;kstack + PGSIZE; return p;&#125; 4.在schduler添加页表切换，切换进程的时候切换页表。 123456789101112131415161718192021222324252627282930313233343536373839404142voidscheduler(void)&#123; struct proc *p; struct cpu *c = mycpu(); c-&gt;proc = 0; for(;;)&#123; // Avoid deadlock by ensuring that devices can interrupt. intr_on(); int found = 0; for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; acquire(&amp;p-&gt;lock); if(p-&gt;state == RUNNABLE) &#123; // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-&gt;state = RUNNING; c-&gt;proc = p; w_satp(MAKE_SATP(p-&gt;krnl_pagetable)); sfence_vma(); swtch(&amp;c-&gt;context, &amp;p-&gt;context); kvminithart(); // Process is done running for now. // It should have changed its p-&gt;state before coming back. c-&gt;proc = 0; found = 1; &#125; release(&amp;p-&gt;lock); &#125;#if !defined (LAB_FS) if(found == 0) &#123; intr_on(); asm volatile(\"wfi\"); &#125;#else ;#endif &#125;&#125; 5.在freeproc里释放掉内核页表。 先断链接再清空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455voidauto_ukvmmap(pagetable_t now_pagetable)&#123; // uart registers //kvmmap(now_pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W); uvmunmap(now_pagetable, UART0, 1, 0); // virtio mmio disk interface //kvmmap(now_pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); uvmunmap(now_pagetable,VIRTIO0, 1, 0); // CLINT //kvmmap(now_pagetable,CLINT, CLINT, 0x10000, PTE_R | PTE_W); //uvmunmap(now_pagetable,CLINT, 0x10000/PGSIZE, 0); // PLIC //kvmmap(now_pagetable,PLIC, PLIC, 0x400000, PTE_R | PTE_W); uvmunmap(now_pagetable,PLIC, 0x400000/PGSIZE, 0); // map kernel text executable and read-only. //kvmmap(now_pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); uvmunmap(now_pagetable,KERNBASE, PGROUNDUP((uint64)etext-KERNBASE)/PGSIZE, 0); // map kernel data and the physical RAM we'll make use of. //kvmmap(now_pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); uvmunmap(now_pagetable,(uint64)etext, PGROUNDUP((PHYSTOP-(uint64)etext))/PGSIZE, 0); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. //kvmmap(now_pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); uvmunmap(now_pagetable,TRAMPOLINE, 1 , 0);&#125;static voidfreeproc(struct proc *p)&#123; if(p-&gt;trapframe) kfree((void*)p-&gt;trapframe); p-&gt;trapframe = 0; if(p-&gt;krnl_pagetable)&#123; auto_ukvmmap(p-&gt;krnl_pagetable); uvmunmap(p-&gt;krnl_pagetable,0,PGROUNDUP(p-&gt;sz)/PGSIZE,0); //kfree((void*)kvmpa(p-&gt;kstack,p-&gt;krnl_pagetable)); uvmunmap(p-&gt;krnl_pagetable,p-&gt;kstack,1,1); //printf(\"yes\\n\"); uvmfree(p-&gt;krnl_pagetable,0); &#125;// vmprint(p-&gt;krnl_pagetable);// uvmfree(p-&gt;krnl_pagetable, 0); p-&gt;krnl_pagetable=0; if(p-&gt;pagetable) proc_freepagetable(p-&gt;pagetable, p-&gt;sz); p-&gt;pagetable = 0; p-&gt;sz = 0; p-&gt;pid = 0; p-&gt;parent = 0; p-&gt;name[0] = 0; p-&gt;chan = 0; p-&gt;killed = 0; p-&gt;xstate = 0; p-&gt;state = UNUSED;&#125; Simplify copyin/copyinstr (hard) 任务描述 让copyin/copyinstr函数去内存的时候不需要再用pagetable而是直接寻址，加快copyin/copyinstr的效率。 实现方法：将进程user态的内存复制一份到进程的k_pagetable里，就可以在kernel中直接解引用。 任务步骤 1.修改copyin/copyinstr为更新后的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071intcopyin_new(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len);intcopyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)&#123; return copyin_new(pagetable,dst,srcva,len); uint64 n, va0, pa0; while(len &gt; 0)&#123; va0 = PGROUNDDOWN(srcva); pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (srcva - va0); if(n &gt; len) n = len; memmove(dst, (void *)(pa0 + (srcva - va0)), n); len -= n; dst += n; srcva = va0 + PGSIZE; &#125; return 0;&#125;// Copy a null-terminated string from user to kernel.// Copy bytes to dst from virtual address srcva in a given page table,// until a '\\0', or max.// Return 0 on success, -1 on error.intcopyinstr_new(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max);intcopyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)&#123; return copyinstr_new(pagetable,dst,srcva,max); uint64 n, va0, pa0; int got_null = 0; while(got_null == 0 &amp;&amp; max &gt; 0)&#123; va0 = PGROUNDDOWN(srcva); pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (srcva - va0); if(n &gt; max) n = max; char *p = (char *) (pa0 + (srcva - va0)); while(n &gt; 0)&#123; if(*p == '\\0')&#123; *dst = '\\0'; got_null = 1; break; &#125; else &#123; *dst = *p; &#125; --n; --max; p++; dst++; &#125; srcva = va0 + PGSIZE; &#125; if(got_null)&#123; return 0; &#125; else &#123; return -1; &#125;&#125; 2.增加函数vmcopypage。 1234567891011voidvmcopypage(pagetable_t pagetable,pagetable_t krnl_pagetable,uint64 start,uint64 sz)&#123; for(uint64 i=start;i&lt;start+sz;i+=PGSIZE)&#123; pte_t* pte=walk(pagetable,i,0); pte_t* krnl_pte=walk(krnl_pagetable,i,1); if(!pte||!krnl_pte)&#123; panic(\"vmcopypage\"); &#125; *krnl_pte=(*pte)&amp;~(PTE_U|PTE_U|PTE_X); &#125;&#125; 3.在sys_sbrk，userinit，fork，exec中都增加对user页表的复制。 exec中要释放掉旧用户的user页表，并且加上PLIC的限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209uint64sys_sbrk(void)&#123; int addr; int n; struct proc *p=myproc(); if(argint(0, &amp;n) &lt; 0) return -1; addr = p-&gt;sz; if(growproc(n) &lt; 0) return -1; if(n&gt;0)&#123; vmcopypage(p-&gt;pagetable,p-&gt;krnl_pagetable,addr,n); &#125;else&#123; for(int j=addr-PGSIZE;j&gt;=addr+n;j-=PGSIZE)&#123; uvmunmap(p-&gt;krnl_pagetable,j,1,0); &#125; &#125; return addr;&#125;voiduserinit(void)&#123; struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy init's instructions // and data into it. uvminit(p-&gt;pagetable, initcode, sizeof(initcode)); p-&gt;sz = PGSIZE; vmcopypage(p-&gt;pagetable,p-&gt;krnl_pagetable,0,p-&gt;sz); // prepare for the very first \"return\" from kernel to user. p-&gt;trapframe-&gt;epc = 0; // user program counter p-&gt;trapframe-&gt;sp = PGSIZE; // user stack pointer safestrcpy(p-&gt;name, \"initcode\", sizeof(p-&gt;name)); p-&gt;cwd = namei(\"/\"); p-&gt;state = RUNNABLE; release(&amp;p-&gt;lock);&#125;intfork(void)&#123; int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0)&#123; return -1; &#125; // Copy user memory from parent to child. if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0)&#123; freeproc(np); release(&amp;np-&gt;lock); return -1; &#125; np-&gt;sz = p-&gt;sz; vmcopypage(np-&gt;pagetable,np-&gt;krnl_pagetable,0,np-&gt;sz); np-&gt;parent = p; // copy saved user registers. *(np-&gt;trapframe) = *(p-&gt;trapframe); // Cause fork to return 0 in the child. np-&gt;trapframe-&gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i &lt; NOFILE; i++) if(p-&gt;ofile[i]) np-&gt;ofile[i] = filedup(p-&gt;ofile[i]); np-&gt;cwd = idup(p-&gt;cwd); safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name)); pid = np-&gt;pid; np-&gt;state = RUNNABLE; release(&amp;np-&gt;lock); return pid;&#125;intexec(char *path, char **argv)&#123; char *s, *last; int i, off; uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase; struct elfhdr elf; struct inode *ip; struct proghdr ph; pagetable_t pagetable = 0, oldpagetable; struct proc *p = myproc(); begin_op(); if((ip = namei(path)) == 0)&#123; end_op(); return -1; &#125; ilock(ip); // Check ELF header if(readi(ip, 0, (uint64)&amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; if(elf.magic != ELF_MAGIC) goto bad; if((pagetable = proc_pagetable(p)) == 0) goto bad; // Load program into memory. for(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph))&#123; if(readi(ip, 0, (uint64)&amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; if(ph.type != ELF_PROG_LOAD) continue; if(ph.memsz &lt; ph.filesz) goto bad; if(ph.vaddr + ph.memsz &lt; ph.vaddr) goto bad; uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad; sz = sz1; if(ph.vaddr % PGSIZE != 0) goto bad; if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; 0) goto bad; if(sz1&gt;=PLIC) goto bad; &#125; iunlockput(ip); end_op(); ip = 0; p = myproc(); uint64 oldsz = p-&gt;sz; // Allocate two pages at the next page boundary. // Use the second as the user stack. sz = PGROUNDUP(sz); uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) goto bad; sz = sz1; uvmclear(pagetable, sz-2*PGSIZE); sp = sz; stackbase = sp - PGSIZE; // Push argument strings, prepare rest of stack in ustack. for(argc = 0; argv[argc]; argc++) &#123; if(argc &gt;= MAXARG) goto bad; sp -= strlen(argv[argc]) + 1; sp -= sp % 16; // riscv sp must be 16-byte aligned if(sp &lt; stackbase) goto bad; if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) &lt; 0) goto bad; ustack[argc] = sp; &#125; ustack[argc] = 0; // push the array of argv[] pointers. sp -= (argc+1) * sizeof(uint64); sp -= sp % 16; if(sp &lt; stackbase) goto bad; if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) &lt; 0) goto bad; uvmunmap(p-&gt;krnl_pagetable,0,PGROUNDUP(oldsz)/PGSIZE,0); vmcopypage(pagetable,p-&gt;krnl_pagetable,0,sz); // arguments to user main(argc, argv) // argc is returned via the system call return // value, which goes in a0. p-&gt;trapframe-&gt;a1 = sp; // Save program name for debugging. for(last=s=path; *s; s++) if(*s == '/') last = s+1; safestrcpy(p-&gt;name, last, sizeof(p-&gt;name)); // Commit to the user image. oldpagetable = p-&gt;pagetable; p-&gt;pagetable = pagetable; p-&gt;sz = sz; p-&gt;trapframe-&gt;epc = elf.entry; // initial program counter = main p-&gt;trapframe-&gt;sp = sp; // initial stack pointer proc_freepagetable(oldpagetable, oldsz); if(p-&gt;pid==1)vmprint(p-&gt;pagetable); return argc; // this ends up in a0, the first argument to main(argc, argv) bad: if(pagetable) proc_freepagetable(pagetable, sz); if(ip)&#123; iunlockput(ip); end_op(); &#125; return -1;&#125; Grade","path":"2021/09/18/mit6.S081 lab3/"},{"title":"mit6.S081 lab2","text":"Lab syscall: System calls System call tracing (moderate) syscall流程： 调用system call(用户态)-&gt;进入syscall.c作为跳板(内核态)-&gt;跳入具体syscall函数(内核态) 内核态中存在myproc()可以返回一个struct proc中贮存这调用system call的进程的信息。 Sysinfo (moderate) kernel/kalloc.c 内存分配策略： 4kb为一页 空闲内存的页头存在一个指针指向下一个空闲内存的页头，将内存串起来。 kernel/proc.c 进程分配策略： 累计进程号+1（保证了所有线程pid独立） 遍历所有进程： 找到第一个空闲的讲起返回 copyout 用户态和内核态用的内存地址都是独立的 需要用pagetable和copyoout来获取真实的地址来传入传出数据","path":"2021/09/09/mit6.S081 lab2/"},{"title":"mit6.S081 lab1","text":"Lab: Xv6 and Unix utilities sleep (easy) 12345678910111213#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"int main(int argc,char *argv[])&#123;// printf(\"%d\\n\",argc);// for(int i=0;i&lt;argc;i++)printf(\"%s\\n\",argv[i]); if(argc!=2)&#123; printf(\"少了个描述时间的数字\\n\"); &#125;else&#123; sleep(atoi(argv[1])); &#125; exit(0);&#125; pingpong (easy) 1234567891011121314151617181920#include \"kernel/types.h\"#include \"user/user.h\"int main()&#123; int pid; int p[2]; pipe(p); pid=fork(); if(pid==0)&#123; printf(\"%d: received ping\\n\",getpid()); close(p[0]); write(p[1],\"ping-pong\",9); &#125;else&#123; close(p[1]); char a[10]; read(p[0],a,9); // printf(\"%s\\n\",a); printf(\"%d: received pong\\n\",getpid()); &#125; exit(0);&#125; primes (moderate)/(hard) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"kernel/types.h\"#include \"user/user.h\"int flag=0,prime=0;int from[2],to[2],p[2];int receive(int x);int transport(int x);int receive(int x)&#123; if(x==-1)exit(0); printf(\"prime %d\\n\",x); flag=1; prime=x; pipe(p); int pid=fork(); if(pid==0)&#123; flag=0; from[0]=p[0]; from[1]=p[1]; close(from[1]); while(x!=-1)&#123; read(from[0],&amp;x,4); transport(x); &#125; close(from[0]); wait(0); exit(0); &#125;else&#123; to[0]=p[0]; to[1]=p[1]; close(to[0]); &#125; return 0;&#125;int transport(int x)&#123; if(flag==0)receive(x); else&#123; if(x%prime!=0||prime==0)write(to[1],&amp;x,4); &#125; return 0;&#125;int main()&#123; for(int i=2;i&lt;=35;i++)transport(i); transport(-1); close(to[1]); wait(0); exit(0);&#125; find (moderate) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\"char* fmtname(char *path)&#123; static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--); p++; // Return blank-padded name. if(strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf+strlen(p), 0, DIRSIZ-strlen(p)); return buf;&#125;void find(char *path,char *name)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) &lt; 0)&#123; fprintf(2, \"find: cannot open %s\\n\", path); return; &#125; if(fstat(fd, &amp;st) &lt; 0)&#123; fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; &#125; strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123; if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0)&#123; printf(\"ls: cannot stat %s\\n\", buf); continue; &#125; if(st.type==2)&#123; if(strcmp(fmtname(buf),name)==0)printf(\"%s\\n\",buf); &#125; if(st.type==1)&#123; if(strcmp(fmtname(buf),\".\")!=0&amp;&amp;strcmp(fmtname(buf),\"..\")!=0)find(buf,name); &#125; // printf(\"%s %d %d %d\\n\", buf, st.type, st.ino, st.size); &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; find(argv[1],argv[2]); exit(0);&#125; xargs (moderate) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"kernel/types.h\"#include \"user/user.h\"char a[120][120];char *b[120];int c[120];int row,column;char tmp;int solve(char s[],int argc,char *argv[])&#123; int n=strlen(s); int A=0; for(int i=1;i&lt;argc;i++)&#123; b[A]=argv[i]; A++; &#125; b[A]=&amp;s[0]; A++; for(int i=0;i&lt;n;i++)&#123; if(s[i]==' ')&#123; s[i]=0; b[A]=&amp;s[i+1]; A++; &#125; &#125; b[A]=0; //for(int i=0;i&lt;A;i++)printf(\"AA::%s\\n\",b[i]); exec(argv[1],b); exit(0);&#125;int main(int argc,char *argv[])&#123; while(read(0,&amp;tmp,1))&#123; if(tmp=='\\n')&#123; row++; column=0; // a[row]=new char[120]; continue; &#125; a[row][column++]=tmp; &#125; for(int i=0;i&lt;row;i++)&#123; int pid=fork(); if(pid==0)&#123; solve(a[i],argc,argv); exit(0); &#125; &#125;// for(int i=0;i&lt;row;i++)wait(0); while(wait(0)!=-1); exit(0);&#125;","path":"2021/09/08/mit6.S081 lab1/"}]}