{"pages":[],"posts":[{"title":"2018暑假计划","text":"总进度：（107/300） 总错误： MLE:1 RE:1 精度：1 细节错误：2 struct数组大会不稳定，namespace比较稳定：1 树的重心：1 可持久化的继承状态：1 2018-8-7 SS（0/100）(构造+KMP) Tree Game（100/100） (博弈论) 二元运算(100/100)(分治+FFT) 2018-8-6 Tree（100/100）(树形DP) 异或运算（100/100） (可持久化trie) Tree Restoring(10/100)(构造) Tree Restoring(10/100)(构造) 2018-7-31 JLOI2015 战争调度(100/100)（树形DP） CQOI2015 选数(100/100)（莫比乌斯反演+杜教筛） YNOI2017 由乃的OJ(30/100)（树链剖分+贪心）场上没写完。 总体而言没有大的失误，但C题没写完还是有点可惜，场后不到二十分钟就A掉了。 2018-7-31 Mushroom 追妹纸(100/100)（二分加hash） 抵制克苏恩(100/100)（概率与期望） 烁烁的游戏(30/100)（可持久化线段树）一开始以为是n2n^2n​2​​暴力乱搞题，后面发现不对，然后写可持久化线段树（最后场上没写出来的原因是新增的一条链没继承之前的状态）。没调出来就没敢交（幸亏没交）。 终于又有训练赛打了。 2018-7-23 礼物(100/100) 小奇的博弈(20/100)（逻辑语句写错） 烁烁的游戏(10/100)打的就是暴力，然后学了动态树分治，觉得这题蛮ok。 2018-7-22 (这场训练赛太水了，全部人都ak了，就不写了) 2018-7-21 训练赛： Division expression(100/100) 清理雪道(100/100) 奇数国(50/100)发现struct开大数组会不稳定，以后改用namespace 场上得分(250/300) 今天还去看了看前两天被卡技能树的拓展crt（我还是更喜欢抽出质因子直接crt），写了道模板题。 2018-7-20 NOI网络同步赛： 第一题写了很久才过了大样例，但因为用了set以及crt合并时三个数直接乘在一起，再加上用的是lower_bound，从一百崩成五十，第二题没交上去。（CCF的服务器是真的垃圾。） 总观这次同步赛，现在最大的问题不是我想不到，而是我眼高手低，手速跟不上自己的思维，并且没有完全理顺就开始写，以及注释加的不够，导致写的过程中较为混乱（场上大家都会进水，只是进多少的问题了。）。还有就是受环境干扰太大。接下来的训练中还得加强对代码复杂度较高的题的训练，并且还得再了解多一些编译原理，避免系统之间的误差出错。 心中想到的做法是能进集训队的分，打出来的是却是铜牌靠前得分。从前路一直看过来，我的问题一直都不是思维不严谨，也不是粗心什么的，更不是运气。而是一个眼高手低的问题，学东西过于偏向于理论，而轻视实践。接下来的训练就是要排掉自己写的不熟的东西，加快自己的写码速度。 NOI2018 屠龙勇士 2018-7-19 训练赛： PRZ(100/100) Race(37/100)错因：求重心时返回值出错 Milk Patterns(100/100) 场上得分(237/300) 2018-7-18 NOI网络同步赛： A了一题，剩下的暴力一分没拿，算上送的笔试（140/350），不过比较不擅长的字符串考完了（68分送的，然而最后一小时自闭了，没写出来。）希望后天能翻盘吧。 NOI 2018归程 2018-7-17 训练赛： Find the outlier(0/100)eps精度出错 征服王(0/100)想当然地写然后思路错误 相似字串(0/100)模板打错 场上得分(0/300) 今天的情绪不是很高，文化课炸了，虽然早就有预计，但这样下去不太行。接下来的日子里不仅是OI得搞，文化课也得补了，计划暑假得把理综的知识点和英语的单词语法给搞定了。 在课堂上觉得十分没有效率，所以索性就放弃了，或许是不适应课堂的那种节奏吧。接下来全都是自学，也没有什么借口能给自己找了。总之按照之前布置的作业，把本该做的做了吧。 今天还爆了0，真是充满负能量的一天，一晚上啥也没做，满脑子都是挥之不去的负面想法，后路是自己断的，现在想要重新准备后路的也是自己，相当于是把前段时间的工作都推到了暑假，策略上有点失误了。现在自己满脑子都是自己彻底失败的后果，也不是太清醒，明天就是网络同步赛，愿能给自己前段时间的一点交代吧。我不想否定我考前一个月逃各种课写码的时间，所以明天这种错误一定不能犯了啊。 文化课炸了我找的借口是去搞OI了，而今天OI暴零了，我又想给自己找去文化课状态没回过来的借口。但这样应该是不行的啊。找再多借口也不能改变暴零的事情，找再多借口也挽回不了文化课已经远远落下，愿自己不再找借口，别人也不再帮我找借口，以后考砸了，只有一个原因，就是实力太垃圾。 在qq里跟父母讲了近况，得到了理解和支持，虽然眼前是一片迷茫，但摸着黑也要走下去。我相信我的智商和付出。 今天还刷了几题水题，但都觉得没有写题解的意义，不加入做题数。 2018-7-16 大包子的完美组合 等差子序列 普通平衡树 训练赛： gcd(100/100) 次小生成树 tree(100/100) k个串 kstring(10/100)失分原因：NM打反导致线段树节点不够。 场上得分：(210/300) 2018-7-15 JSOI2008 火星人prefix Bracket zuma 训练赛： 兔子与樱花(100/100) 矩阵乘法(100/100) 聪聪可可(100/100) 场上得分(300/300) 2018-7-14 rank sequence string 训练赛： game with probability(100/100) 病毒(100/100) Count on a tree(0/100)失分原因:MLE 场上得分(200/300)","path":"2018/08/01/暑假计划/"},{"title":"YNOI2017 由乃的OJ","text":"题目描述: NOI2014起床困难综合征的树上版本。 题解: 说实话我觉得这种直接把序列上的东西搬到树上的题很没水平。还有就是在不涉及其他的情况下卡unsigned long long卡了六十分，这还是作为一道省选题，我觉得出题人的出题水平很差劲。首先题目本身没有新意，并且在不是那么重要的东西上过分追求。就只是为了卡人而出的题，真的糟糕。（虽然我发现了unsigned long long 但这种用longlong难度不会变但硬是要卡的做法，我很鄙视。） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 217000 #define ll unsigned long long using namespace std; int tot,Next[N],h[N],v[N],f[N][25]; ll I=1,A,B; ll n,m,k,a[N],t[N],O; int dep[N],siz[N],top[N],st[N],son[N],ed[N]; inline ll merge(ll x,ll A,ll B){ ll ans=0; ans=(x&amp;B)|((~x)&amp;A); return ans; } inline ll cal(ll x,int type,ll y){ if(type==1)return x&amp;y; if(type==2)return x|y; if(type==3)return x^y; } namespace seg{ ll up[N*4][2],down[N*4][2]; int bing(int i,int x,int y){ down[i][0]=merge(down[x][0],down[y][0],down[y][1]); down[i][1]=merge(down[x][1],down[y][0],down[y][1]); up[i][0]=merge(up[y][0],up[x][0],up[x][1]); up[i][1]=merge(up[y][1],up[x][0],up[x][1]); } int build(int i,int l,int r){ if(l==r){ up[i][0]=cal(0,t[st[l]],a[st[l]]); up[i][1]=cal(O,t[st[l]],a[st[l]]); down[i][0]=cal(0,t[st[l]],a[st[l]]); down[i][1]=cal(O,t[st[l]],a[st[l]]); return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); bing(i,i*2,i*2+1); } int insert(int i,int l,int r,int x){ if(l==r){ up[i][0]=cal(0,t[st[l]],a[st[l]]); up[i][1]=cal(O,t[st[l]],a[st[l]]); down[i][0]=cal(0,t[st[l]],a[st[l]]); down[i][1]=cal(O,t[st[l]],a[st[l]]); return 0; } int mid=(l+r)/2; if(x&lt;=mid)insert(i*2,l,mid,x); else insert(i*2+1,mid+1,r,x); bing(i,i*2,i*2+1); } int query_up(int i,int l,int r,int x,int y){ if(x&lt;=l&amp;&amp;y&gt;=r){ A=merge(A,up[i][0],up[i][1]); B=merge(B,up[i][0],up[i][1]); return 0; } int mid=(l+r)/2; if(y&gt;mid)query_up(i*2+1,mid+1,r,x,y); if(x&lt;=mid)query_up(i*2,l,mid,x,y); } int query_down(int i,int l,int r,int x,int y){ if(x&lt;=l&amp;&amp;y&gt;=r){ A=merge(A,down[i][0],down[i][1]); B=merge(B,down[i][0],down[i][1]); return 0; } int mid=(l+r)/2; if(x&lt;=mid)query_down(i*2,l,mid,x,y); if(y&gt;mid)query_down(i*2+1,mid+1,r,x,y); } } int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ dep[x]=dep[fa]+1; f[x][0]=fa; for(int i=1;i&lt;=17;i++)f[x][i]=f[f[x][i-1]][i-1]; siz[x]=1; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); siz[x]+=siz[v[i]]; if(siz[v[i]]&gt;siz[son[x]])son[x]=v[i]; } } int dfs1(int x,int fa){ st[++tot]=x; ed[x]=tot; if(son[x]){ top[son[x]]=top[x]; dfs1(son[x],x); } for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; if(v[i]==son[x])continue; top[v[i]]=v[i]; dfs1(v[i],x); } } int lca(int x,int y){ for(;top[x]!=top[y];dep[top[x]]&gt;dep[top[y]]?x=f[top[x]][0]:y=f[top[y]][0]); return dep[x]&lt;dep[y]?x:y; } int get(int x,int y){ for(int i=17;i&gt;=0;i--)if(dep[f[y][i]]&gt;dep[x])y=f[y][i]; return y; } int lfs(int x,int fa){ if(dep[top[x]]&gt;dep[fa])lfs(f[top[x]][0],fa); else{ seg::query_down(1,1,n,ed[fa],ed[x]); return 0; } seg::query_down(1,1,n,ed[top[x]],ed[x]); } int solve(int x,int y,int z){ while(dep[top[x]]&gt;dep[z]) seg::query_up(1,1,n,ed[top[x]],ed[x]),x=f[top[x]][0]; seg::query_up(1,1,n,ed[z],ed[x]); if(z==y)return 0; z=get(z,y); lfs(y,z); } int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++){ scanf(&quot;%llu%llu&quot;,&amp;t[i],&amp;a[i]); } for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs(1,0); tot=0; top[1]=1; dfs1(1,0); O=(I&lt;&lt;(k-1))-1+(I&lt;&lt;(k-1)); seg::build(1,1,n); for(int i=1;i&lt;=m;i++){ ll x,y,v; ll type; scanf(&quot;%llu&quot;,&amp;type); if(type==1){ scanf(&quot;%llu%llu%llu&quot;,&amp;x,&amp;y,&amp;v); int z=lca(x,y); A=0,B=O; solve(x,y,z); ll ans=0,bns=0; for(int i=k-1;i&gt;=0;i--){ ll oo=I&lt;&lt;i; if(A&amp;oo)bns+=oo; if((B&amp;oo)&amp;&amp;!(A&amp;oo)&amp;&amp;ans+oo&lt;=v)ans+=oo,bns+=oo; } printf(&quot;%llu\\n&quot;,bns); }else{ scanf(&quot;%llu%llu%llu&quot;,&amp;x,&amp;y,&amp;v); t[x]=y; a[x]=v; seg::insert(1,1,n,ed[x]); } } } 题目链接: Ynoi2017 由乃的OJ","path":"2018/08/01/YNOI2017-由乃的OJ/"},{"title":"CQOI2015 选数","text":"题目描述: 我们知道，从区间[L,H][L,H][L,H](L和H为整数)中选取NNN个整数，总共有(H−L+1)N(H-L+1)^N(H−L+1)​N​​种方案。小z很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的NNN个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小z会告诉你一个整数KKK，你需要回答他最大公约数刚好为KKK的选取方案有多少个。由于方案数较大，你只需要输出其除以100000000710000000071000000007的余数即可。 题解: 直接推反演式子然后杜教筛暴力堆上去即可。（好像还有一种容斥做法会快一点，不过限制也多一点，杜教筛不用H-L的数量限制，还是很优秀的。） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;map&gt; #define N 3000000 #define P 1000000007 using namespace std; int mu[N],p[N],tot,prime[N],f[N]; map&lt;long long,int&gt;g; long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int pre(){ mu[1]=1; f[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0)prime[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0){ mu[i*prime[j]]=0; break; } } f[i]=f[i-1]+mu[i]; } } long long cal(int x){ if(x==0)return 0; if(x&lt;N-10)return f[x]; if(g[x])return g[x]; long long ans=1; for(long long i=2;i&lt;=x;i++){ int j=x/(x/i); ans-=(j-i+1)*cal(x/i); i=j; } g[x]=ans; return ans; } int main(){ pre(); long long ans=0; int n,k,l,r; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;l,&amp;r); l=(l-1)/k; r=r/k; int m=(r-l)+1; cal(l); cal(r); int j; for(int i=1;i&lt;=r;i++){ if(l/i&gt;0)j=min(l/(l/i),r/(r/i)); else j=r/(r/i); (ans+=1LL*(cal(j)-cal(i-1))*power(r/i-l/i,n))%=P; i=j; } ans%=P; ans+=P; ans%=P; printf(&quot;%lld\\n&quot;,ans); } 题目链接:CQOI2015 选数","path":"2018/08/01/SCOI2015-选数/"},{"title":"JLOI2015 战争调度","text":"题目描述: 脸哥最近来到了一个神奇的王国，王国里的公民每个公民有两个下属或者没有下属，这种关系刚好组成一个nnn层的完全二叉树。公民iii的下属是2×i2\\times i2×i 和2×i+12\\times i+12×i+1。最下层的公民即叶子节点的公民是平民，平民没有下属，最上层的是国王，中间是各级贵族。现在这个王国爆发了战争，国王需要决定每一个平民是去种地以供应粮食还是参加战争，每一个贵族（包括国王自己）是去管理后勤还是领兵打仗。一个平民会对他的所有直系上司有贡献度，若一个平民iii参加战争，他的某个直系上司jjj领兵打仗，那么这个平民对上司的作战贡献度为wi,jw_{i,j}w​i,j​​。若一个平民iii种地，他的某个直系上司jjj管理后勤，那么这个平民对上司的后勤贡献度为fi,jf_{i,j}f​i,j​​，若 i 和 j 所参加的事务不同，则没有贡献度。为了战争需要保障后勤，国王还要求不多于 m 个平民参加战争。国王想要使整个王国所有贵族得到的贡献度最大，并把这件事交给了脸哥。但不幸的是，脸哥还有很多 deadline 没有完成，他只能把这件事又转交给你。你能帮他安排吗？(我能不帮他安排吗？) #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200 using namespace std; int n,w[N][12],v[N][12],f[N][N],p[12]; int dfs(int x,int d){ int i,j; for(i=0;i&lt;=1&lt;&lt;d;i++)f[x][i]=0; if(!d){ for(i=1;i&lt;=n;i++){ if(p[i])f[x][1]+=w[x][i]; else f[x][0]+=v[x][i]; } return 0; } p[d]=0,dfs(x&lt;&lt;1,d-1),dfs(x&lt;&lt;1|1,d-1); for(i=0;i&lt;=1&lt;&lt;(d-1);i++) for(j=0;j&lt;=1&lt;&lt;(d-1);j++) f[x][i+j]=max(f[x][i+j],f[x&lt;&lt;1][i]+f[x&lt;&lt;1|1][j]); p[d]=1,dfs(x&lt;&lt;1,d-1),dfs(x&lt;&lt;1|1,d-1); for(i=0;i&lt;=1&lt;&lt;(d-1);i++) for(j=0;j&lt;=1&lt;&lt;(d-1);j++) f[x][i+j]=max(f[x][i+j],f[x&lt;&lt;1][i]+f[x&lt;&lt;1|1][j]); } int main(){ int m,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n--; for(int i=0;i&lt;(1&lt;&lt;n);i++)for(int j=1;j&lt;=n;j++)scanf(&quot;%d&quot;,&amp;w[i+(1&lt;&lt;n)][j]); for(int i=0;i&lt;(1&lt;&lt;n);i++)for(int j=1;j&lt;=n;j++)scanf(&quot;%d&quot;,&amp;v[i+(1&lt;&lt;n)][j]); dfs(1,n); for(int i=0;i&lt;=m;i++)ans=max(ans,f[1][i]); printf(&quot;%d\\n&quot;,ans); } 题目链接:JLOI2015 战争调度","path":"2018/08/01/JLOI2015-战争调度/"},{"title":"pyh的求和","text":"题目描述: 给出n,m，求: ∑i=1n∑j=1mφ(ij)\\sum_{i=1}^{n}\\limits\\sum_{j=1}^m \\limits\\varphi(ij)​i=1​∑​n​​​j=1​∑​m​​φ(ij) 总共求T组，n,m,t都是10510^510​5​​级别的数。 题解: φ(ij)=φ(i)×φ(j)×dφ(d)(d=gcd(i,j))\\varphi(ij)=\\varphi(i)\\times \\varphi(j)\\times \\frac{d}{\\varphi(d)}(d=gcd(i,j))φ(ij)=φ(i)×φ(j)×​φ(d)​​d​​(d=gcd(i,j)) ∑i=1n∑j=1mφ(ij)\\sum_{i=1}^{n}\\limits\\sum_{j=1}^m \\limits\\varphi(ij)​i=1​∑​n​​​j=1​∑​m​​φ(ij) =∑i=1n∑j=1mφ(i)φ(j)dφ(d)=\\sum_{i=1}^{n}\\limits\\sum_{j=1}^m \\limits\\varphi(i)\\varphi(j) \\frac{d}{\\varphi(d)}=​i=1​∑​n​​​j=1​∑​m​​φ(i)φ(j)​φ(d)​​d​​ =∑d=1ndφ(d)∑i=1⌊nd⌋∑j=1⌊md⌋φ(id)φ(jd)[gcd(i,j)=1]=\\sum_{d=1}^n\\limits \\frac{d}{\\varphi(d)}\\sum_{i=1}^{\\lfloor \\frac{n}d{}\\rfloor}\\limits \\sum_{j=1}^{\\lfloor\\frac{m} {d}\\rfloor}\\limits \\varphi(id)\\varphi(jd)[gcd(i,j)=1]=​d=1​∑​n​​​φ(d)​​d​​​i=1​∑​⌊​d​​n​​⌋​​​j=1​∑​⌊​d​​m​​⌋​​φ(id)φ(jd)[gcd(i,j)=1] =∑d=1ndφ(d)∑i=1⌊nd⌋∑j=1⌊md⌋φ(id)φ(jd)∑k∣i,k∣jμ(k)=\\sum_{d=1}^n\\limits \\frac{d}{\\varphi(d)}\\sum_{i=1}^{\\lfloor \\frac{n}d{}\\rfloor}\\limits \\sum_{j=1}^{\\lfloor\\frac{m} {d}\\rfloor}\\limits \\varphi(id)\\varphi(jd)\\sum_{k|i,k|j}\\limits \\mu(k)=​d=1​∑​n​​​φ(d)​​d​​​i=1​∑​⌊​d​​n​​⌋​​​j=1​∑​⌊​d​​m​​⌋​​φ(id)φ(jd)​k∣i,k∣j​∑​​μ(k) =∑k=1nμ(k)∑d=1⌊nd⌋dφ(d)∑i=1⌊ndk⌋∑j=1⌊mdk⌋φ(ikd)φ(jkd)=\\sum_{k=1}^{n}\\limits\\mu(k)\\sum_{d=1}^{\\lfloor \\frac{n}{d}\\rfloor}\\limits \\frac{d}{\\varphi(d)}\\sum_{i=1}^{\\lfloor \\frac{n}{dk}\\rfloor}\\limits \\sum_{j=1}^{\\lfloor\\frac{m} {dk}\\rfloor}\\limits \\varphi(ikd)\\varphi(jkd)=​k=1​∑​n​​μ(k)​d=1​∑​⌊​d​​n​​⌋​​​φ(d)​​d​​​i=1​∑​⌊​dk​​n​​⌋​​​j=1​∑​⌊​dk​​m​​⌋​​φ(ikd)φ(jkd)(枚举k) =∑c=1n∑d∣cμ(cd)dφ(d)∑i=1⌊nc⌋∑j=1⌊mc⌋φ(ic)φ(jc)=\\sum_{c=1}^{n}\\limits\\sum_{d|c}\\limits \\mu(\\frac{c}{d})\\frac{d}{\\varphi(d)}\\sum_{i=1}^{\\lfloor \\frac{n}{c}\\rfloor}\\limits \\sum_{j=1}^{\\lfloor\\frac{m} {c}\\rfloor}\\limits \\varphi(ic)\\varphi(jc)=​c=1​∑​n​​​d∣c​∑​​μ(​d​​c​​)​φ(d)​​d​​​i=1​∑​⌊​c​​n​​⌋​​​j=1​∑​⌊​c​​m​​⌋​​φ(ic)φ(jc)（枚举c=kd）记 记f(n)=∑d∣nμ(nd)dφ(d)f(n)=\\sum_{d|n}\\limits \\mu(\\frac{n}{d})\\frac{d}{\\varphi(d)}f(n)=​d∣n​∑​​μ(​d​​n​​)​φ(d)​​d​​ =∑c=1nf(c)∑i=1⌊nc⌋φ(ic)∑j=1⌊mc⌋φ(jc)=\\sum_{c=1}^{n}f(c)\\sum_{i=1}^{\\lfloor \\frac{n}{c}\\rfloor}\\limits \\varphi(ic)\\sum_{j=1}^{\\lfloor\\frac{m} {c}\\rfloor}\\limits \\varphi(jc)=∑​c=1​n​​f(c)​i=1​∑​⌊​c​​n​​⌋​​φ(ic)​j=1​∑​⌊​c​​m​​⌋​​φ(jc) 记S(n,k)S(n,k)S(n,k)为∑i=1nφ(ik)\\sum_{i=1}^n\\varphi(ik)∑​i=1​n​​φ(ik) =∑c=1nf(c)S(⌊nc⌋,c)S(⌊mc⌋,c)=\\sum_{c=1}^nf(c)S(\\lfloor \\frac{n}{c}\\rfloor,c)S(\\lfloor \\frac{m}{c}\\rfloor,c)=∑​c=1​n​​f(c)S(⌊​c​​n​​⌋,c)S(⌊​c​​m​​⌋,c) f(c)f(c)f(c)和S(x,c)S(x,c)S(x,c)都可以利用调和级数预处理出来。 但是我们每次不能O(n)求，考虑对原式进行分块。 我们预处理一个T(i,j,k)=∑x=1kS(i,x)∗S(j,x)T(i,j,k)=\\sum_{x=1}^k\\limits S(i,x)*S(j,x)T(i,j,k)=​x=1​∑​k​​S(i,x)∗S(j,x)（i和j至于处理到35） 当c&lt;=⌊n35⌋c&lt;=\\lfloor \\frac{n}{35}\\rfloorc&lt;=⌊​35​​n​​⌋时直接暴力累加。 当c&gt;⌊n35⌋c&gt;\\lfloor\\frac{n}{35}\\rfloorc&gt;⌊​35​​n​​⌋时,原式中S的第一个系数都小于35，那就可以用T(i,j,k)数论分块叠加上去。（至于为什么是35，调参调出来的）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 998244353 #define N 120000 #define K 35 using namespace std; int prime[N],phi[N],p[N],h[N],mu[N]; long long a[N*120],b[N*60],tot,cnt,inv[N],f[N]; int pre(){ mu[1]=1; phi[1]=1; for(int i=2;i&lt;N-10;i++){ if(p[i]==0){ prime[++tot]=i; phi[i]=i-1; mu[i]=-1; } for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;N-10;j++){ p[i*prime[j]]=1; phi[i*prime[j]]=phi[i]*phi[prime[j]]; mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0){ mu[i*prime[j]]=0; phi[i*prime[j]]=phi[i]*prime[j]; break; } } } } long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } long long T(int x,int y,int j){ int i=(x*(K+1)+y); return b[p[i]+j]; } long long G(int i,int j){ if(h[i]+j&gt;=h[i+1])return 0; return a[h[i]+j]; } int ppre(){ int n=100000; for(int i=1;i&lt;=n;i++)inv[i]=power(i,P-2); memset(p,0,sizeof(p)); for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) f[j]=(f[j]+1LL*mu[j/i]*i*inv[phi[i]]%P+P)%P; for(int i=1;i&lt;=n;i++){ tot++; h[i]=tot; for(int j=1;j&lt;=n/i;j++)a[++tot]=(a[tot-1]+phi[i*j])%P; } cnt=0; long long pp=0; for(int j=1;j&lt;=K;j++) for(int k=j;k&lt;=K;k++){ int o=j*(K+1)+k; p[o]=++cnt; b[cnt]=0; int len=n/max(j,k); pp+=len; for(int i=1;i&lt;=len;i++){ cnt++; b[cnt]=(b[cnt-1]+1LL*f[i]*G(i,j)%P*G(i,k)%P)%P; } } } long long solve(int n,int m){ if(n&gt;m)swap(n,m); long long ans=0; for(int i=1;i&lt;=m/K;i++)ans=(ans+1LL*f[i]*G(i,n/i)%P*G(i,m/i)%P)%P; for(int i=m/K+1;i&lt;=n;i++){ int j=min(n/(n/i),m/(m/i)); ans=(ans+T(n/i,m/i,j)-T(n/i,m/i,i-1)+P)%P; i=j; } return ans; } int main(){ pre(); tot=0; ppre(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%lld\\n&quot;,solve(n,m)); } } 题目链接： Pyh的求和","path":"2018/07/31/pyh的求和/"},{"title":"Mushroom 追妹纸","text":"题目描述： Mushroom最近看上了一个漂亮妹纸。他选择一种非常经典的手段来表达自己的心意——写情书。考虑到自己的表达能力，Mushroom决定不手写情书。他从网上找到了两篇极佳的情书，打算选择其中共同的部分。另外，Mushroom还有个一个情敌Ertanis，此人也写了封情书给妹子。 Mushroom不希望自己的情书中完整的出现了情敌的情书。（这样抄袭的事情就暴露了）。 Mushroom把两封情书分别用字符串s1和s2来表示，Ertanis的情书用字符串s3来表示，他要截取的部分用字符串w表示。 需满足： 1、w是s1的子串 2、w是s2的子串 3、s3不是w的子串 4、w的长度应尽可能大 所谓子串是指：在字符串中连续的一段 题解： 发现答案具有二分性，又发现可以O（n）扫描当前答案是否可行，那就直接二分答案加hash就搞完了。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define G 37 #define P 1000000007 #define N 120000 using namespace std; char s1[N],s2[N],w[N]; long long n,m,k,a[N],b[N],pw[N],oo,h; map&lt;int,int&gt; o; int pre(){ h=0; pw[0]=1; for(int i=1;i&lt;=max(n,m);i++)pw[i]=(1LL*pw[i-1]*G)%P; for(int i=1;i&lt;=k;i++)h=(h*G+w[i]-'a'+1)%P; oo=0; for(int i=1;i&lt;=k;i++)oo=(oo*G%P+s1[i]-'a'+1)%P; a[1]=oo==h; for(int i=k+1;i&lt;=n;i++){ oo=((oo-pw[k-1]*(s1[i-k]-'a'+1)%P))*G+s1[i]-'a'+1; oo=oo%P; if(oo&lt;0)oo+=P; a[i-k+1]=oo==h; } } int check(int x){ if(x==0)return 1; o.clear(); h=0; int u=0; int f; for(int i=1;i&lt;=x;i++){ if(i&gt;=k)u+=a[i-k+1]; h=(1LL*h*G+s1[i]-'a'+1)%P; } if(u==0||x&lt;k)o[h]=1; // printf(&quot;%d &quot;,h); for(int i=x+1;i&lt;=n;i++){ if(i&gt;=k)u+=a[i-k+1]; u-=a[i-x]; h=(h-pw[x-1]*(s1[i-x]-'a'+1)%P)*G+s1[i]-'a'+1; h=h%P; if(h&lt;0)h+=P; // printf(&quot;%d &quot;,h); if(u==0||x&lt;k)o[h]=1; } // printf(&quot;\\n&quot;); oo=0; for(int i=1;i&lt;=x;i++)oo=(1LL*oo*G+s2[i]-'a'+1)%P; if(o[oo]==1)return 1; // printf(&quot;%d &quot;,oo); for(int i=x+1;i&lt;=m;i++){ oo=(oo-pw[x-1]*(s2[i-x]-'a'+1)%P)*G+s2[i]-'a'+1; oo=oo%P; // printf(&quot;%d &quot;,oo); if(oo&lt;0)oo+=P; if(o[oo]==1)return 1; } // printf(&quot;\\n&quot;); return 0; } int main(){ scanf(&quot;%s&quot;,s1+1); scanf(&quot;%s&quot;,s2+1); scanf(&quot;%s&quot;,w+1); n=strlen(s1+1),m=strlen(s2+1),k=strlen(w+1); pre(); int l=0,r=min(n,m); while(r-l&gt;2){ int mid=(l+r)/2; if(check(mid))l=mid; else r=mid-1; } for(int i=r;i&gt;=l;i--){ if(check(i)){ printf(&quot;%d\\n&quot;,i); return 0; } } } 题目链接： Mushroom追妹纸","path":"2018/07/31/Mushroom追妹纸/"},{"title":"抵制克苏恩","text":"题目描述： 小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌召唤至多 7 个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么。 现在小Q同学会给出克苏恩的攻击力是 K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选择一个并对其产生 1 点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1 点，当其血量小于等于 0 时会死亡，如果受到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3 点血量的新奴隶主作为你的随从；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1 点伤害。你应该注意到了，每当克苏恩进行一次攻击，你场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3 点血量的奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？ 题解： 因为数据范围着实小，所以直接列出方程记忆化搜索即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; long double g[60][8][8][8]; long double f(int k,int a,int b,int c){ long double ans=0; int o=1+a+b+c; if(g[k][a][b][c]&gt;0)return g[k][a][b][c]; if(k==1)return 1.0/o; ans=1.0/o+1.0/o*f(k-1,a,b,c); if(a)ans+=(a+0.0)/o*f(k-1,a-1,b,c); if(b){ if(a+b+c&lt;7)ans+=(b+0.0)/o*f(k-1,a+1,b-1,c+1); else ans+=(b+0.0)/o*f(k-1,a+1,b-1,c); } if(c){ if(a+b+c&lt;7)ans+=(c+0.0)/o*f(k-1,a,b+1,c); else ans+=(c+0.0)/o*f(k-1,a,b+1,c-1); } g[k][a][b][c]=ans; return g[k][a][b][c]; } int main(){ int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ int k,a,b,c; scanf(&quot;%d%d%d%d&quot;,&amp;k,&amp;a,&amp;b,&amp;c); printf(&quot;%.2Lf\\n&quot;,f(k,a,b,c)); } } 题目链接： Lydsy1704月赛 抵制克苏恩","path":"2018/07/31/抵制克苏恩/"},{"title":"SCOI2016 美味","text":"题目： 一家餐厅有nnn道菜，编号1...n1...n1...n，大家对第 i 道菜的评价值为 ai(1≤i≤n)a_i(1\\leq i\\leq n)a​i​​(1≤i≤n)。有 m 位顾客，第 i 位顾客的期望值为 bi，而他的偏好值为 xi 。因此，第 i 位顾客认为第 j 道菜的美味度为biXOR(aj+xi)b_i XOR (a_j+x_i)b​i​​XOR(a​j​​+x​i​​)，XORXORXOR表示异或运算。第 i 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第lil_il​i​​道到第rir_ir​i​​道中选择。请你帮助他们找出最美味的菜。 题解： 贪心每一位，然后确定区间，用可持久化线段树确认当前区间是否有值。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 5230000 using namespace std; int a[N],ans,X,K,root[N]; namespace seg{ int t[N],tot,lx[N],rx[N]; int insert(int i,int j,int l,int r,int x){ if(l==r){ t[j]=t[i]+1; return 0; } int mid=(l+r)/2; if(x&lt;=mid){ lx[j]=++tot; rx[j]=rx[i]; insert(lx[i],lx[j],l,mid,x); } else{ lx[j]=lx[i]; rx[j]=++tot; insert(rx[i],rx[j],mid+1,r,x); } t[j]=t[lx[j]]+t[rx[j]]; } int query(int i,int j,int l,int r,int x,int y){ if(x&lt;=l&amp;&amp;y&gt;=r)return t[i]-t[j]; int ans=0; int mid=(l+r)/2; if(x&lt;=mid)ans+=query(lx[i],lx[j],l,mid,x,y); if(y&gt;mid)ans+=query(rx[i],rx[j],mid+1,r,x,y); return ans; } int Query(int i,int j,int x,int y){ x++; y++; if(x&lt;=0&amp;&amp;y&lt;=0)return 0; if(y&lt;=0)return 0; x=max(x,1);y=max(y,1); return (query(i,j,1,1&lt;&lt;18,x,y)); } } int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); root[i]=++seg::tot; a[i]++; seg::insert(root[i-1],root[i],1,1&lt;&lt;18,a[i]); } for(int i=1;i&lt;=m;i++){ int x,y; scanf(&quot;%d%d%d%d&quot;,&amp;X,&amp;K,&amp;x,&amp;y); ans=0; int l=0,L,R; for(int i=17;i&gt;=0;i--){ int o=(X&amp;(1&lt;&lt;i)); if(o==0){//o 0 a 1 L=l+(1&lt;&lt;i); R=l+(1&lt;&lt;(i+1))-1; if(seg::Query(root[y],root[x-1],L-K,R-K)&gt;0)l=L; } else{//o 1 a 0 L=l; R=l+(1&lt;&lt;(i))-1; if(seg::Query(root[y],root[x-1],L-K,R-K)&lt;=0)l=l+(1&lt;&lt;i); } } printf(&quot;%d\\n&quot;,l^X); } } 题目链接： Scoi2016 美味","path":"2018/07/31/美味/"},{"title":"杜教筛","text":"求一类积性函数的前缀和 例题: ans=∑i=1nμ(i)ans=\\sum_{i=1}^{n}\\limits\\mu(i)ans=​i=1​∑​n​​μ(i)，n&lt;=1011n&lt;=10^{11}n&lt;=10​11​​ 前情提要： ∑d∣nμ(d)=[n=1]\\sum_{d|n}\\limits\\mu(d)=[n=1]​d∣n​∑​​μ(d)=[n=1] 证明（不想看证明也可以把这个当结论用）： ∑d∣nμ(d)=∑i=0xCxi×(−1)i\\sum_{d|n}\\limits\\mu(d)=\\sum_{i=0}^x\\limits C_{x}^{i}\\times (-1)^i​d∣n​∑​​μ(d)=​i=0​∑​x​​C​x​i​​×(−1)​i​​（x为n的质因数个数） ∑d∣nμ(d)=∑i=02i&lt;=xCx2i−∑i=02i+1&lt;=xCx2i+1\\sum_{d|n}\\limits\\mu(d)=\\sum_{i=0}^{2i&lt;=x}\\limits C_{x}^{2i}-\\sum_{i=0}^{2i+1&lt;=x}\\limits C_{x}^{2i+1}​d∣n​∑​​μ(d)=​i=0​∑​2i&lt;=x​​C​x​2i​​−​i=0​∑​2i+1&lt;=x​​C​x​2i+1​​(-1的奇数次和偶数次) 相当于是对于随意一种组合，如果是奇数就加，如果是偶数就减。 那么我们考虑fif_if​i​​为i个数随意组合选出奇数个的方案数，gig_ig​i​​为i个数随意选出偶数个的方案数。对于每新加进来的一个数，有选和不选两种方案。 fi+1=gi+fif_{i+1}=g_i+f_if​i+1​​=g​i​​+f​i​​(选和不选) gi+1=fi+gig_{i+1}=f_i+g_ig​i+1​​=f​i​​+g​i​​(选和不选) ∑d∣nμ(d)=gx−fx\\sum_{d|n}\\limits\\mu(d)=g_x-f_x​d∣n​∑​​μ(d)=g​x​​−f​x​​(x为n的质因数个数) 并且按照定义得知(f1=g1=1f_1=g_1=1f​1​​=g​1​​=1)。所以除了n=1的情况（0个质因数，f0=0,g0=1f_0=0,g_0=1f​0​​=0,g​0​​=1），其他的fi=gif_i=g_if​i​​=g​i​​，因此上式成立。 杜教筛： 我们现在要求∑i=1nμ(i)\\sum_{i=1}^n\\limits\\mu(i)​i=1​∑​n​​μ(i),那么我们用上面式子对于μ(i)\\mu(i)μ(i)转化一下 ∑d∣iμ(d)=[i=1]\\sum_{d|i}\\limits\\mu(d)=[i=1]​d∣i​∑​​μ(d)=[i=1] μ(i)+∑d∣i,d&lt;iμ(d)=[i=1]\\mu(i)+\\sum_{d|i,d&lt;i}\\limits\\mu(d)=[i=1]μ(i)+​d∣i,d&lt;i​∑​​μ(d)=[i=1] μ(i)=[i=1]−∑d∣i,d&lt;iμ(d)\\mu(i)=[i=1]-\\sum_{d|i,d&lt;i}\\limits\\mu(d)μ(i)=[i=1]−​d∣i,d&lt;i​∑​​μ(d) 再求一个前缀和变成我们要求的东西。 ∑i=1nμ(i)=1−∑i=1n∑d∣i,d&lt;iμ(d)\\sum_{i=1}^n\\limits \\mu(i)=1-\\sum_{i=1}^n\\limits \\sum_{d|i,d&lt;i}\\limits\\mu(d)​i=1​∑​n​​μ(i)=1−​i=1​∑​n​​​d∣i,d&lt;i​∑​​μ(d) 对于∑i=1n∑d∣i,d&lt;iμ(d)\\sum_{i=1}^n\\limits \\sum_{d|i,d&lt;i}\\limits\\mu(d)​i=1​∑​n​​​d∣i,d&lt;i​∑​​μ(d)我们考虑i=d×xi=d\\times xi=d×x，对于每个x&gt;2x&gt;2x&gt;2,μ(d)\\mu(d)μ(d)都会被统计答案（x不能等于1因为d&lt;id&lt;id&lt;i）。那么我们考虑枚举x。 ∑i=1n∑d∣i,d&lt;iμ(d)=∑x=2n∑d=1⌊nx⌋μ(d)\\sum_{i=1}^n\\limits \\sum_{d|i,d&lt;i}\\limits\\mu(d)=\\sum_{x=2}^n\\limits \\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(d)​i=1​∑​n​​​d∣i,d&lt;i​∑​​μ(d)=​x=2​∑​n​​∑​d=1​⌊​x​​n​​⌋​​μ(d) 我们考虑f(x)f(x)f(x)为∑i=1xμ(i)\\sum_{i=1}^{x}\\limits\\mu(i)​i=1​∑​x​​μ(i)。 那么f(n)=1−∑i=2nf(ni)f(n)=1-\\sum_{i=2}^{n}\\limits f(\\frac{n}{i})f(n)=1−​i=2​∑​n​​f(​i​​n​​) 那就可以预处理完以后记忆化搜索，可在O(n34)O(n^{\\frac{3}{4}})O(n​​4​​3​​​​)(调参可变为O(n23)O(n^{\\frac 2 3})O(n​​3​​2​​​​))得到结果。 时间复杂度证明： T(n)=∑i=1⌊n⌋O(i)+∑i=1⌊n⌋O(ni)=∑i=1⌊n⌋O(ni)≈O(∫1⌊n⌋nxdx)=O(n34)T(n)=\\sum\\limits_{i=1}^{\\left\\lfloor\\sqrt n\\right\\rfloor}O\\left(\\sqrt i\\right)+\\sum\\limits_{i=1}^{\\left\\lfloor\\sqrt n\\right\\rfloor}O\\left(\\sqrt{\\frac ni}\\right)=\\sum\\limits_{i=1}^{\\left\\lfloor\\sqrt n\\right\\rfloor}O\\left(\\sqrt{\\frac ni}\\right)\\approx O\\left(\\int_1^{\\left\\lfloor\\sqrt n\\right\\rfloor}\\sqrt{\\frac nx}\\mathrm dx\\right)=O\\left(n^{\\frac34}\\right)T(n)=​i=1​∑​⌊√​n​​​⌋​​O(√​i​​​)+​i=1​∑​⌊√​n​​​⌋​​O(√​​i​​n​​​​​)=​i=1​∑​⌊√​n​​​⌋​​O(√​​i​​n​​​​​)≈O(∫​1​⌊√​n​​​⌋​​√​​x​​n​​​​​dx)=O(n​​4​​3​​​​) 按照分块的思想，当预处理nnn到n23n^{\\frac 2 3}n​​3​​2​​​​的时候，时间复杂度最小，为O(n23)O(n^{\\frac2 3})O(n​​3​​2​​​​)。 T(n)=∑i=1⌊n13⌋O(ni)≈O(n23)T(n)=\\sum\\limits_{i=1}^{\\left\\lfloor n^{\\frac13}\\right\\rfloor}O\\left(\\sqrt{\\frac ni}\\right)\\approx O\\left(n^{\\frac23}\\right)T(n)=​i=1​∑​⌊n​​3​​1​​​​⌋​​O(√​​i​​n​​​​​)≈O(n​​3​​2​​​​) 算法流程： 若要求f(i)f(i)f(i)的前缀和，找到∑d∣nf(d)\\sum_{d|n}f(d)∑​d∣n​​f(d)的值（如果可以快速求的话）。 然后把f(n)f(n)f(n)拉出来，左右做等式，然后前缀和后化为记忆化搜索的形式。 再预处理后记忆化搜索即可。","path":"2018/07/26/杜教筛/"},{"title":"【Array Poisonous Suffix Problem】","text":"题目大意： Are you going to solve poisonous problems? - Thanks a lot for today’s poisonous problems. What are you doing at the end of the world? Are you busy? Will you save us? Ithea and Chtholly want to play a game in order to determine who will solve poisonous problems. - Willem… Lakhesh loves to make poisonous problems, so Nephren helps her run a cinema. We may call it No. 68 Cinema. - I… I survived. 如题目背景所述，这是一道 PSP（Poisonous String Problem，毒瘤字符串题）。 对于一个正整数k，若任何一个 $1∼n $的排列均是某个字符集大小不超过k的字符串的后缀排名数组（后缀排名数组即后缀数组的逆排列，如果你不知道什么是后缀数组，可以自行搜索或参考Wiki 对后缀数组的介绍），则称k对于n是毒瘤的。给定k，你需要找到一个最小的正整数n使k对于n不是毒瘤的，并且你需要给出1∼n的一个排列，其不是任何一个字符集大小不超过k的字符串的后缀排名数组。如果有多个排列，输出字典序最小的，如果不存在这样的n和排列，输出 213。 一句话题意： 给出一个k，k为字符集大小，求出最小的n使得存在一个排列使得没有一个长度为n的字符串的sa数组是这个排列。 前情提要： saisa_isa​i​​表示的是排名为i的后缀的起始位置。 题解： n最小为k+1，因为k个字符的话每个字符不同可使sa达到全排列。 我们设g(x)g(x)g(x)为字符串Sx...nS_{x...n}S​x...n​​,我们现在考虑一个排列a，使得g(a1)&lt;g(a2)&lt;g(a3)&lt;...&lt;g(an)g(a_1)&lt;g(a_2)&lt;g(a_3)&lt;...&lt;g(a_n)g(a​1​​)&lt;g(a​2​​)&lt;g(a​3​​)&lt;...&lt;g(a​n​​)。 那么，我们要达成的要求就是使得Sa1&lt;Sa2&lt;Sa3&lt;...&lt;SanS_{a_1}&lt;S_{a_2}&lt;S_{a_3}&lt;...&lt;S_{a_n}S​a​1​​​​&lt;S​a​2​​​​&lt;S​a​3​​​​&lt;...&lt;S​a​n​​​​(字符集为n-1,所以要有n个严格小于的关系)。 考虑g(ai)&lt;g(ai+1)g(a_i)&lt;g(a_{i+1})g(a​i​​)&lt;g(a​i+1​​)，我们要使Sai&lt;Sai+1S_{a_i}&lt;S_{a_{i+1}}S​a​i​​​​&lt;S​a​i+1​​​​，那么必须要使g(ai+1)&gt;g(ai+1+1)g(a_i+1)&gt;g(a_{i+1}+1)g(a​i​​+1)&gt;g(a​i+1​​+1)(因为g(x)g(x)g(x)相当于是SxS_{x}S​x​​与g(x+1)g(x+1)g(x+1)拼凑出来的字符串，而为了严格小于，字典序小的第二位开始的后缀必须要大于字典序大的)。 那么便有： g(n+1)&lt;g(a1)&lt;g(a2)&lt;g(a3)&lt;...&lt;g(an)g(n+1)&lt;g(a_1)&lt;g(a_2)&lt;g(a_3)&lt;...&lt;g(a_n)g(n+1)&lt;g(a​1​​)&lt;g(a​2​​)&lt;g(a​3​​)&lt;...&lt;g(a​n​​)(g(n+1)g(n+1)g(n+1)为空串)（g里的值域为1到n+1） g(an+1)&lt;g(an−1+1)&lt;g(an−2+1)&lt;...&lt;g(a1+1)g(a_n+1)&lt;g(a_{n-1}+1)&lt;g(a_{n-2}+1)&lt;...&lt;g(a_1+1)g(a​n​​+1)&lt;g(a​n−1​​+1)&lt;g(a​n−2​​+1)&lt;...&lt;g(a​1​​+1)（g里的值域为2到n+1） 上面与下面一一对应（除了当上方g中的ax=1a_{x}=1a​x​​=1时）（也就是上面比下面多一项，除了这一项，其他都是一一对应的） an+1=n+1a_n+1=n+1a​n​​+1=n+1（上方的第一项已经确定n+1≠1n+1\\neq1n+1≠1） ana_na​n​​确定后，a1a_1a​1​​又可以确定，这样递归确定下去，知道axa_xa​x​​等于1了，就可以推出。 可以发现，满足要求的排列是唯一的。并且，这个求出来的，是sa的逆数组rk数组，再返回去，就可以O(n)O(n)O(n)得到答案。 也可以归纳一下变成下面代码的形式。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int a[120000],n,tot; int main(){ int n; scanf(&quot;%d&quot;,&amp;n); n++; printf(&quot;%d\\n&quot;,n); if(n%2){ for(int i=n-1;i;i-=2)a[i]=++tot; for(int i=1;i&lt;=n;i+=2)a[i]=++tot; }else{ for(int i=n-1;i&gt;0;i-=2)a[i]=++tot; for(int i=2;i&lt;=n;i+=2)a[i]=++tot; } for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]); } 题目链接：「LibreOJ β Round #7」Array Poisonous Suffix Problem","path":"2018/07/25/「LibreOJ-β-Round-7」Array-Poisonous-Suffix-Problem/"},{"title":"HAOI2016 找相同字符","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1220000 using namespace std; long long fx[N],fy[N]; long long ans; namespace sam{ int ch[N][27]; int len[N],fail[N],tot=1,last=1,v[N],q[N]; int newnode(int x){ len[++tot]=x; return tot; } int extend(int x){ int p=last; if(ch[p][x]&amp;&amp;len[ch[p][x]]==len[p]+1)return ch[p][x]; int np=newnode(len[p]+1); while(p&amp;&amp;!ch[p][x])ch[p][x]=np,p=fail[p]; if(p==0)fail[np]=1; else{ int q=ch[p][x]; if(len[q]==len[p]+1)fail[np]=q; else{ int nq=newnode(len[p]+1); memcpy(ch[nq],ch[q],sizeof(ch[nq])); fail[nq]=fail[q]; fail[q]=fail[np]=nq; while(p&amp;&amp;ch[p][x]==q)ch[p][x]=nq,p=fail[p]; } } last=np; return last; } int pre(){ for(int i=1;i&lt;=tot;i++)v[len[i]]++; for(int i=1;i&lt;=tot;i++)v[i]+=v[i-1]; for(int i=1;i&lt;=tot;i++)q[v[len[i]]--]=i; } int get(){ for(int i=tot;i&gt;=1;i--){ int t=q[i]; fx[fail[t]]+=fx[t]; fy[fail[t]]+=fy[t]; } for(int i=1;i&lt;=tot;i++)ans+=fx[i]*fy[i]*(len[i]-len[fail[i]]); } } char s[N]; int main(){ int n,x; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) sam::last=sam::extend(s[i]-'a'+1),fx[sam::last]++; sam::last=1; n=strlen(s+1); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++)sam::last=sam::extend(s[i]-'a'+1),fy[sam::last]++; sam::pre(); sam::get(); printf(&quot;%lld\\n&quot;,ans); } #2064. 「HAOI2016」找相同字符","path":"2018/07/25/HAOI2016-找相同字符/"},{"title":"SDOI2016 诸神眷顾的幻想乡","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define N 320000 using namespace std; namespace sam{ map&lt;int,int&gt;ch[N]; int len[N],fail[N],tot=1,last=1; long long ans; int newnode(int x){ len[++tot]=x; return tot; } int extend(int x){ int p=last; int np=newnode(len[p]+1); while(p&amp;&amp;!ch[p][x])ch[p][x]=np,p=fail[p]; if(p==0)fail[np]=1; else{ int q=ch[p][x]; if(len[q]==len[p]+1)fail[np]=q; else{ int nq=newnode(len[p]+1); ch[nq]=ch[q]; fail[nq]=fail[q]; fail[q]=fail[np]=nq; //ans+=len[nq]-len[fail[nq]]; while(p&amp;&amp;ch[p][x]==q)ch[p][x]=nq,p=fail[p]; } } ans+=len[np]-len[fail[np]]; last=np; return last; } } int main(){ int n,x; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x); sam::extend(x); printf(&quot;%lld\\n&quot;,sam::ans); } } 题目链接「SDOI2016」生成魔咒","path":"2018/07/25/SDOI2016-生成魔咒/"},{"title":"TJOI2015 弦论","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200000 using namespace std; int n; char s[N]; long long T,K; namespace sam{ int ch[N][27],fail[N],last,len[N],val[N],tot,v[N],q[N],sum[N]; int newnode(int x){ len[++tot]=x; return tot; } int extend(int x){ int p=last; int np=newnode(len[p]+1); val[np]=1; while(p&amp;&amp;!ch[p][x])ch[p][x]=np,p=fail[p]; if(p==0)fail[np]=1; else{ int q=ch[p][x]; if(len[q]==len[p]+1)fail[np]=q; else{ int nq=newnode(len[p]+1); memcpy(ch[nq],ch[q],sizeof(ch[q])); fail[nq]=fail[q]; fail[q]=fail[np]=nq; while(ch[p][x]==q)ch[p][x]=nq,p=fail[p]; } } last=np; return last; } int pre(){ for(int i=1;i&lt;=tot;i++)v[len[i]]++; for(int i=1;i&lt;=n;i++)v[i]+=v[i-1]; for(int i=tot;i;i--)q[v[len[i]]--]=i; for(int i=tot;i;i--){ int t=q[i]; if(T==1)val[fail[t]]+=val[t]; else val[t]=1; } val[1]=0; for(int i=tot;i;i--){ int t=q[i];sum[t]=val[t]; for(int j=1;j&lt;=26;j++) sum[t]+=sum[ch[t][j]]; } } int dfs(int x,int k){ if(k&lt;=val[x])return 0; k-=val[x]; for(int i=1;i&lt;=26;i++) if(int t=ch[x][i]){ if(k&lt;=sum[t]){ putchar(i+'a'-1); dfs(t,k); return 0; } k-=sum[t]; } } } int main(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); scanf(&quot;%lld%lld&quot;,&amp;T,&amp;K); sam::last=sam::tot=1; for(int i=1;i&lt;=n;i++)sam::extend(s[i]-'a'+1); sam::pre(); if(K&gt;sam::sum[1])puts(&quot;-1&quot;); else sam::dfs(1,K); } 题目链接:「TJOI2015」弦论","path":"2018/07/25/TJOI2015-弦论/"},{"title":"ZJOI2015 诸神眷顾的幻想乡","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 220000 #define M 12000000 using namespace std; int tot,Next[N],v[N],h[N],w[N],d[N]; int cnt,len[M],ch[M][15],fail[M],last; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int newnode(int x){ cnt++; len[cnt]=x; return cnt; } int extend(int p,int x){ int np=newnode(len[p]+1); while(p&amp;&amp;!ch[p][x])ch[p][x]=np,p=fail[p]; if(p==0)fail[np]=1; else{ int q=ch[p][x]; if(len[q]==len[p]+1)fail[np]=q; else{ int nq=newnode(len[p]+1); memcpy(ch[nq],ch[q],sizeof(ch[q])); fail[nq]=fail[q]; fail[np]=fail[q]=nq; while(ch[p][x]==q)ch[p][x]=nq,p=fail[p]; } } last=np; return np; } int dfs(int x,int fa,int now){ int k=extend(now,w[x]); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x,k); } } int main(){ int n,c; scanf(&quot;%d%d&quot;,&amp;n,&amp;c); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]),w[i]++; len[++cnt]=0,last=1; for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); d[x]++,d[y]++; } for(int i=1;i&lt;=n;i++)if(d[i]==1)dfs(i,0,1); long long ans=0; for(int i=1;i&lt;=cnt;i++)ans+=(0LL+len[i]-len[fail[i]]); printf(&quot;%lld\\n&quot;,ans); } 题目链接:「ZJOI2015」诸神眷顾的幻想乡","path":"2018/07/25/ZJOI2015-诸神眷顾的幻想乡/"},{"title":"烁烁的游戏","text":"题目大意： 背景：烁烁很喜欢爬树，这吓坏了树上的皮皮鼠。 题意： 给定一颗n个节点的树，边权均为1，初始树上没有皮皮鼠。烁烁他每次会跳到一个节点u，把周围与他距离不超过d的节点各吸引出w只皮皮鼠。皮皮鼠会被烁烁吸引，所以会一直待在节点上不动。 烁烁很好奇，在当前时刻，节点u有多少个他的好朋友—皮皮鼠。 大意： 给一颗n个节点的树，边权均为1，初始点权均为0，m次操作： Q x：询问x的点权。 M x d w：将树上与节点x距离不超过d的节点的点权均加上w。 题解： 建出点分树以后容斥用线段树求后缀和即可。（虽然每层都扫好暴力但好像复杂度就是对的） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define N 301700 #define M 5170000 using namespace std; int b[N]; int tot,cnt,siz[N]; int h[N],Next[N],v[N],p[N],son[N],ans; int root[N],rt[N],ff[N],l[N]; vector&lt;int&gt;q1[N],q[N]; namespace seg{ int t[M],lx[M],rx[M],tot; int insert(int i,int l,int r,int x,int a){ if(i==0)i=++tot; if(l==r){ t[i]+=a; return i; } int mid=(l+r)/2; if(lx[i]==0)lx[i]=++tot; if(rx[i]==0)rx[i]=++tot; if(x&lt;=mid)insert(lx[i],l,mid,x,a); else insert(rx[i],mid+1,r,x,a); t[i]=t[lx[i]]+t[rx[i]]; return i; } int query(int i,int l,int r,int x,int y){ if(t[i]==0)return 0; if(x&lt;=l&amp;&amp;r&lt;=y)return t[i]; if(lx[i]==0)lx[i]=++tot; if(rx[i]==0)rx[i]=++tot; int mid=(l+r)/2; int ans=0; if(mid&gt;=x)ans+=query(lx[i],l,mid,x,y); if(mid&lt;y)ans+=query(rx[i],mid+1,r,x,y); return ans; } } void pre(int x,int fa,int l){//vector b[++cnt]=l; siz[x]=1; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; if(p[v[i]]==1)continue; pre(v[i],x,l+1); siz[x]+=siz[v[i]]; } } int get(int x,int fa,int oo,int l){//重心 //vector //节点我不要了 son[x]=0; b[++cnt]=l;//深度 for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; if(p[v[i]]==1)continue; get(v[i],x,oo,l+1); son[x]=max(son[x],siz[v[i]]); } son[x]=max(son[x],oo-siz[x]); if(son[ans]&gt;son[x])ans=x; return ans; } void dfs(int x){ cnt=0; pre(x,0,1); // printf(&quot;%d\\n&quot;,siz[x]); sort(b+1,b+1+cnt); cnt=unique(b+1,b+1+cnt)-b-1; // printf(&quot;%d\\n&quot;,x); rt[x]=seg::insert(0,1,cnt,1,0); for(int j=1;j&lt;=cnt;j++)q[x].push_back(b[j]); p[x]=1; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; ans=0; cnt=0; son[0]=0x7fffffff; int oo=get(v[i],x,siz[v[i]],1); ff[oo]=x; l[oo]=v[i]; sort(b+1,b+1+cnt); cnt=unique(b+1,b+1+cnt)-b-1; for(int j=1;j&lt;=cnt;j++)q1[oo].push_back(b[j]); root[oo]=seg::insert(0,1,cnt,1,0); dfs(oo); } } int dep[N],f[N][22]; int lca(int x,int y){ if(dep[x]&lt;dep[y])swap(x,y); for(int i=17;i&gt;=0;i--)if(dep[f[x][i]]&gt;=dep[y])x=f[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; return f[x][0]; } void dfs1(int x,int fa){ dep[x]=dep[fa]+1; f[x][0]=fa; for(int i=1;i&lt;=17;i++)f[x][i]=f[f[x][i-1]][i-1]; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; // printf(&quot;%d %d\\n&quot;,v[i],x); dfs1(v[i],x); } } char s[2]; int dis(int x,int y){ return dep[x]+dep[y]-dep[lca(x,y)]*2; } int query(int x){//q rt重心 q1 root连接点 int oo=x; int ans=0; while(x){ int X=dis(oo,x);X++; int k=X; k=max(k,0); int F=q[x].size(); if(k&amp;&amp;k&lt;=F)ans+=seg::query(rt[x],1,q[x].size(),k,q[x].size()); // printf(&quot;%d %d %d\\n&quot;,x,k,ans); X=dis(oo,l[x]);X++; F=q1[x].size(); k=X; k=max(k,0); if(k&amp;&amp;k&lt;=F)ans+=seg::query(root[x],1,q1[x].size(),k,q1[x].size()); // printf(&quot;%d %d %d\\n&quot;,l[x],k,ans); x=ff[x]; } return ans; } void insert(int x,int d,int w){ int o=x; d++; while(x){ int dd=dis(x,o); // for(int i=0;i&lt;q[x].size();i++)printf(&quot;%d &quot;,q[x][i]); int k=d-dd; k=max(k,0); k=min(k,(int)q[x].size()); // printf(&quot;%d %d\\n&quot;,x,k); if(k)seg::insert(rt[x],1,q[x].size(),k,w); k=d-dis(l[x],o)-2*dis(ff[x],l[x]); k=max(k,0); k=min(k,(int)q1[x].size()); if(k)seg::insert(root[x],1,q1[x].size(),k,-w); // printf(&quot;%d %d\\n&quot;,l[x],k); x=ff[x]; } // printf(&quot;\\n&quot;); } void add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } // int o=0; // for(int i=1;i&lt;=tot;i++)o=max(o,v[i]); // printf(&quot;%d\\n&quot;,o); dfs1(1,0); dfs(1); for(int i=1;i&lt;=m;i++){ scanf(&quot;%s&quot;,s+1); if(s[1]=='Q'){ int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(x)); } else{ int x,d,w; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;d,&amp;w); insert(x,d,w); } } } 题目链接： 烁烁的游戏","path":"2018/07/24/烁烁的游戏/"},{"title":"小奇的博弈","text":"题目大意： 这个游戏是在一个1*n的棋盘上进行的，棋盘上有k个棋子，一半是黑色，一半是白色。最左边是白色棋子，最右边 是黑色棋子，相邻的棋子颜色不同。 小奇可以移动白色棋子，提比可以移动黑色的棋子，它们每次操作可以移动1到d个棋子。每当移动某一个棋子时， 这个棋子不能跨越两边的棋子，当然也不可以出界。当谁不可以操作时，谁就失败了。小奇和提比轮流操作，现在 小奇先移动，有多少种初始棋子的布局会使它有必胜策略？ 题解： 网上已经有诸多题解了，其中有一些说这题缺了限制条件，但我分析了一下，可能不太需要。 缺限制条件的原因是当白棋进入必败点后，他可以通过加石子的方式来使得黑棋进入必败点。 但是，白棋能加的棋子是有限的，而只要白棋加石子，黑旗就能跟进，那么就可以还原成之前的局面，并且白棋能加的棋子变少了，这里是谁先进入必败点谁就输。就是，如果一种状态进入到必败点，虽然可以继续转移到必败点（这里的必败点是与到终点时输的在某种意义上相同的状态），但是会消耗一些东西（可增加的空间），而另一方跟进是无消耗的，最后是谁先进入必败点谁就输了。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 1000000007 using namespace std; long long C[12000][120],f[20][12000]; long long n,k,d; int main(){ scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;d); for(int i=0;i&lt;=n;i++){ C[i][0]=1; for(int j=1;j&lt;=i&amp;&amp;j&lt;=k;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; } f[0][0]=1; for(long long i=0;i&lt;=16;i++) for(long long j=0;j&lt;=n-k;j++) for(long long x=0;x&lt;=n-k;x++){ if(x*(d+1)&gt;k/2||x*(d+1)*(1ll&lt;&lt;i)+j&gt;n-k)break; f[i+1][j+x*(d+1)*(1ll&lt;&lt;i)]=(f[i+1][j+x*(d+1)*(1ll&lt;&lt;i)]+f[i][j]*C[k/2][x*(d+1)])%P; } long long ans=C[n][k]; for(int i=0;i&lt;=n-k;i++)ans=(ans-f[16][i]*C[n-k-i+k/2][k/2]%P)%P; ans%=P; ans+=P; ans%=P; printf(&quot;%lld\\n&quot;,ans); } 题目链接： 小奇的博弈","path":"2018/07/24/小奇的博弈/"},{"title":"礼物","text":"题目： 我的室友最近喜欢上了一个可爱的小女生。马上就要到她的生日了，他决定买一对情侣手环，一个留给自己，一个送给她。每个手环上各有 n 个装饰物，并且每个装饰物都有一定的亮度。但是在她生日的前一天，我的室友突然发现他好像拿错了一个手环，而且已经没时间去更换它了！他只能使用一种特殊的方法，将其中一个手环中所有装饰物的亮度增加一个相同的自然数 c（即非负整数）。并且由于这个手环是一个圆，可以以任意的角度旋转它，但是由于上面 装饰物的方向是固定的，所以手环不能翻转。需要在经过亮度改造和旋转之后，使得两个手环的差异值最小。在将两个手环旋转且装饰物对齐了之后，从对齐的某个位置开始逆时针方向对装饰物编号 1,2,…,n，其中 n 为每个手环的装饰物个数，第 1 个手环的 i 号位置装饰物亮度为xix_ix​i​​，第 2 个手 环的 i 号位置装饰物亮度为yiy_iy​i​​，两个手环之间的差异值为(参见输入输出样例和样例解释)： ∑i=1n(xi−yi)2\\sum_{i=1}^{n}(x_i-y_i)^2∑​i=1​n​​(x​i​​−y​i​​)​2​​麻烦你帮他计算一下，进行调整（亮度改造和旋转），使得两个手环之间的差异值最小， 这个最小值是多少呢？ 题解： 将(xi−yi)2(x_i-y_i)^2(x​i​​−y​i​​)​2​​乘开以后fft暴力就好了。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;complex&gt; #include&lt;math.h&gt; #define N 350000 #define E complex&lt;double&gt; using namespace std; E a[N],b[N]; double pi=acos(-1); int r[N],n,m,x,L; int s,A[N],B[N]; int DFT(E *a,int f){ for(int i=0;i&lt;n;i++)if(r[i]&gt;i)swap(a[i],a[r[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1){ E wn(cos(pi/i),f*sin(pi/i)); for(int j=0;j&lt;n;j+=i&lt;&lt;1){ E w(1,0); for(int k=0;k&lt;i;k++,w*=wn){ E tmp=w*a[j+k+i]; a[j+k+i]=a[j+k]-tmp; a[j+k]+=tmp; } } } } long long bns; int pre(){ int type; n=s+s+1,m=s+1;L=0; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(r,0,sizeof(r)); for(int i=0;i&lt;n;i++)a[i]=A[i]; for(int i=0;i&lt;m;i++)b[i]=B[i]; m=n+m;n=1; while(n&lt;m)n&lt;&lt;=1,L++; for(int i=0;i&lt;n;i++)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)); DFT(a,1); DFT(b,1); for(int i=0;i&lt;n;i++)a[i]=a[i]*b[i]; DFT(a,-1); bns=0; for(int i=s+1;i&lt;=s+s+1;i++)bns=max(bns,(long long)floor(a[i].real()/n+0.5)); // for(int i=0;i&lt;=m;i++)printf(&quot;%d &quot;,(int)floor(a[i].real()/n+0.5)); // printf(&quot;\\n&quot;); } long long sum; int main(){ int m; scanf(&quot;%d%d&quot;,&amp;s,&amp;m); long long cns=0,ans=1000000000000LL; for(int i=1;i&lt;=s;i++)scanf(&quot;%d&quot;,&amp;B[i]); for(int i=1;i&lt;=s;i++)scanf(&quot;%d&quot;,&amp;A[s-i+1]),A[s+s-i+1]=A[s-i+1]; for(int i=1;i&lt;=s;i++)sum+=A[i]; pre(); for(int i=1;i&lt;=m;i++){ cns=0; for(int i=1;i&lt;=s;i++)cns+=A[i]*A[i]+B[i]*B[i]; cns-=bns*2; if(cns&lt;ans)ans=cns; else break; for(int i=1;i&lt;=s;i++)B[i]++; bns+=sum; } printf(&quot;%lld\\n&quot;,ans); } 题目链接: Hnoi2017 礼物","path":"2018/07/24/礼物/"},{"title":"奇数国","text":"题目大意： 求区间乘积的phi。 题解： 用把有哪些质因数压成longlong，维护乘积，然后乘上逆元变为phi。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 19961993 #define N 8200000 using namespace std; long long prime[1200],p[1200],o[1200],tot,inv[1200]; struct node{ long long x,y;//x为值y为状态 }; long long find(long long x){ long long ans; for(long long i=1;i&lt;=60;i++)if(x%prime[i]==0)ans+=1LL&lt;&lt;i; return ans; } namespace seg{ long long a[N],p[N]; long long build(long long i,long long l,long long r){ if(l==r){ a[i]=3; p[i]=1&lt;&lt;2; return 0; } long long mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); a[i]=a[i*2]*a[i*2+1]%P; p[i]=p[i*2]|p[i*2+1]; } node merge(node x,node y){ node ans; ans.x=x.x*y.x%P; ans.y=x.y|y.y; return ans; } node query(long long i,long long l,long long r,long long x,long long y){ node ans; ans.x=1; ans.y=0; if(x&lt;=l&amp;&amp;r&lt;=y){ ans.x=a[i]; ans.y=p[i]; return ans; } long long mid=(l+r)/2; if(mid&gt;=x)ans=merge(ans,query(i*2,l,mid,x,y)); if(mid&lt;y)ans=merge(ans,query(i*2+1,mid+1,r,x,y)); return ans; } long long insert(long long i,long long l,long long r,long long x,long long A){ if(l==r){ a[i]=A; p[i]=find(A); return 0; } long long mid=(l+r)/2; if(x&lt;=mid)insert(i*2,l,mid,x,A); else insert(i*2+1,mid+1,r,x,A); a[i]=a[i*2]*a[i*2+1]%P; p[i]=p[i*2]|p[i*2+1]; } } long long power(long long x,long long k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } long long pre(){ for(long long i=2;i&lt;300;i++){ if(p[i]==0)prime[++tot]=i,inv[tot]=power(i,P-2),o[i]=tot; for(long long j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;300;j++){ p[i*prime[j]]=1; if(i%prime[j]==0)break; } } } long long cal(node x){ long long ans=x.x; for(long long i=1;i&lt;=60;i++){ if(x.y&amp;(1LL&lt;&lt;i)){ ans=ans*inv[i]%P*(prime[i]-1)%P; } } return ans; } int main(){ pre(); long long n; scanf(&quot;%lld&quot;,&amp;n); seg::build(1,1,100000); for(long long i=1;i&lt;=n;i++){ long long type; scanf(&quot;%lld&quot;,&amp;type); if(type==0){ long long l,r; scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r); printf(&quot;%lld\\n&quot;,cal(seg::query(1,1,100000,l,r))); } if(type==1){ long long x; long long y; scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); seg::insert(1,1,100000,x,y); } } } 题目链接：奇数国","path":"2018/07/21/奇数国/"},{"title":"清理雪道","text":"上下界网络流的板子题。 或者费用流也可以。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #define N 22000 #define INF 100000000 using namespace std; int n,S,T,SS,TT,d[N],cur[N],cnt=1,ans,l[N]; int Next[N],g[N],q[N],w[N],tot=1,h[N],v[N]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; tot++; Next[tot]=h[y]; v[tot]=x; w[tot]=0; h[y]=tot; } bool bfs(){ memset(l,0,sizeof(l)); l[S]=1; q[1]=S; int head=0,tail=1; while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(l[v[i]]==0&amp;&amp;w[i]){ l[v[i]]=l[now]+1; q[++tail]=v[i]; if(v[i]==T)return 1; } } } return 0; } int dfs(int x,int a){ if(x==T||a==0)return a; int ans=0; for(int i=h[x];i;i=Next[i]){ if(a==0)break; if(l[v[i]]!=l[x]+1)continue; if(w[i]==0)continue; int flow=dfs(v[i],min(a,w[i])); ans+=flow; a-=flow; w[i]-=flow; w[i^1]+=flow; } return ans; } void rebuild(){ for(int i=h[S];i;i=Next[i])w[i]=w[i^1]=0; for(int i=h[T];i;i=Next[i])w[i]=w[i^1]=0; for(int i=h[TT];i;i=Next[i]) if(v[i]==SS){ ans+=w[i^1]; w[i]=w[i^1]=0;break; } add(S,TT,INF); add(SS,T,INF); } int main(){ scanf(&quot;%d&quot;,&amp;n);S=n+1;T=n+2;SS=n+3;TT=n+4; for(int i=1,m;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;m); for(int j=1;j&lt;=m;j++){ int x; scanf(&quot;%d&quot;,&amp;x); d[i]--; d[x]++; add(i,x,INF); } } for(int i=1;i&lt;=n;i++){ if(d[i]&gt;0)add(S,i,d[i]); if(d[i]&lt;0)add(i,T,-d[i]); add(SS,i,INF); add(i,TT,INF); } add(TT,SS,INF); while(bfs())dfs(S,INF); rebuild(); while(bfs())ans-=dfs(S,INF); printf(&quot;%d&quot;,ans); return 0; } 题目链接：清理雪道","path":"2018/07/21/清理雪道/"},{"title":"Division expression","text":"题目大意: 给出序列a，问加上括号后a1/a2/a3/a5.../ana_1/a_2/a_3/a_5.../a_na​1​​/a​2​​/a​3​​/a​5​​.../a​n​​能否变为整数。 题解： 发现a2a_2a​2​​一定会是分母，而其他都可以为分子，贪心即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int a[120000],n,x; int gcd(int x,int y){ if(x%y==0)return y; return gcd(y,x%y); } int solve(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); x=a[2]; for(int i=1;i&lt;=n;i++){ if(i==2)continue; x=x/gcd(x,a[i]); if(x==1)return 1; } return 0; } int main(){ int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ if(solve())printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } 题目链接：Division expression","path":"2018/07/21/除法表达式/"},{"title":"NOI2018 屠龙勇士","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;math.h&gt; #include&lt;algorithm&gt; #define N 5200000 using namespace std; vector&lt;long long&gt;prime; multiset&lt;long long&gt;ll; map&lt;long long,long long&gt;w,ww; long long tail,n,m,l[N],lll[N]; struct node{ long long x,p; }q[N]; struct illyasviel{ long long a,p; }a[N]; long long clear(){ w.clear(); prime.clear(); ll.clear(); ww.clear(); tail=0; } long long gcd(long long x,long long y){ if(x%y==0)return y; return gcd(y,x%y); } long long get(long long x,long long p){ // printf(&quot;%lld %lld\\n&quot;,x,p); if(x==-1)return 0; long long k=p; for(long long i=0;i&lt;prime.size();i++){ if(k%prime[i]==0){ long long A,B,P=1; while(k%prime[i]==0)k/=prime[i],P*=prime[i]; // printf(&quot;%d %d\\n&quot;,x,P); q[++tail].x=x%P; q[tail].p=P; long long OOO=P/prime[i]; while(OOO&gt;0)ww[OOO]=1,OOO/=prime[i]; while(P&gt;0){ if(w[P]==0){ if(P==5){ // printf(&quot;%lld %lld\\n&quot;,x,p); } w[P]=x%P; } else{ if(x%P!=w[P]){ // printf(&quot;%lld %lld %lld&quot;,x,w[P],P); return 1; } } // printf(&quot;%d &quot;,w[P]); P/=prime[i]; } } } // printf(&quot;\\n&quot;); return 0; } long long find(long long x){ long long k=sqrt(x); for(long long i=2;i&lt;=k;i++){ if(x%i==0){ while(x%i==0)x/=i; prime.push_back(i); } } if(x&gt;1)prime.push_back(x); // for(long long i=0;i&lt;prime.size();i++)printf(&quot;%lld &quot;,prime[i]); // printf(&quot;\\n&quot;); } bool cmp(node x,node y){ return x.p&gt;y.p; } long long exgcd(long long a1,long long b1,long long &amp;x,long long &amp;y){ if (!b1){x=1; y=0; return a1;} long long gcd=exgcd(b1,a1%b1,x,y),tmp=x; x=y; y=tmp-a1/b1*y; return gcd; } long long phi(long long x){ long long ans=1; for(long long i=0;i&lt;prime.size();i++){ if(x%prime[i]==0){ x/=prime[i]; ans*=prime[i]-1; while(x%prime[i]==0)x/=prime[i],ans*=prime[i]; } } return ans; } long long ppp; long long inv(long long a1,long long mod){ long long x,y; long long gcd=exgcd(a1,mod,x,y); if (gcd!=1) return -1; return (x%mod+mod)%mod; } long long mul(long long x,long long y,long long mod){ long long tmp=x*y-(long long)((long double)x/mod*y+1e-7)*mod; return (tmp+mod)%mod; } long long cal(long long x,long long y,long long p){ long long A=gcd(y,gcd(x,p)); x/=A; y/=A; p/=A; ppp=p; if(gcd(x,p)&gt;1)return -1; long long k=inv(x,p); if(mul(y,k,p)==5&amp;&amp;p==7){ y++;y--; } return mul(y,k,p); } long long PP=100000000000000LL; long long Chinese_Remainder(long long r[],long long prime[],long long len){ long long i,d,x,y,m,n=1,sum=0; // for(long long i=0;i&lt;len;i++)printf(&quot;%lld %lld\\n&quot;,r[i],prime[i]); for(i=0;i&lt;len;i++)n*=prime[i]; for(i=0;i&lt;len;i++){ m=n/prime[i]; d=exgcd(prime[i],m,x,y); sum=(sum+mul(mul(y,m,n),r[i],n))%n; } return (n+sum%n)%n; } long long r[N],pri[N],tto; multiset&lt;long long&gt;::iterator it,pre; long long solve(){//a生命值 p恢复能力 tto=0; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].a); for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].p); for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;lll[i]); for(long long i=1;i&lt;=m;i++)scanf(&quot;%lld&quot;,&amp;l[i]),ll.insert(l[i]); sort(l+1,l+1+n); long long lcm=1; for(long long i=1;i&lt;=m;i++)lcm=lcm/gcd(lcm,a[i].p)*a[i].p; find(lcm); // ll.clear(); ll.insert(-10000000000000LL); long long ans=0; for(long long i=1;i&lt;=n;i++){ long long L; //printf(&quot;%d\\n&quot;,ll.size()); // if(ll.upper_bound(a[i].a)==ll.begin())L=*ll.upper_bound(a[i].a); // else L=*--(ll.upper_bound(a[i].a)); // printf(&quot;%lld\\n&quot;,L); //a[i].a=x*oo(mod a[i].p) it=ll.upper_bound(a[i].a); if (*it==-10000000000000LL) L=*(++it); else{ pre=it; --pre; if (*pre==-10000000000000LL)L=*it; else L=*(--it); } long long sb=cal(L,a[i].a,a[i].p); if(get(sb,ppp))return -1; ans=max(ans,a[i].a/L+(a[i].a%L==0?0:1)); it=ll.find(L); ll.erase(it); ll.insert(lll[i]); } sort(q+1,q+1+tail,cmp); // for(long long i=1;i&lt;=tail;i++)printf(&quot;%d %d\\n&quot;,q[i].x%q[i].p,q[i].p); for(long long i=1;i&lt;=tail;i++){ if(ww[q[i].p]==0){ r[tto]=q[i].x%q[i].p; pri[tto++]=q[i].p; } ww[q[i].p]=1; } // printf(&quot;%lld\\n&quot;,ans); long long bns=Chinese_Remainder(r,pri,tto); if(bns==0)return ans; long long Ans=ans/lcm*lcm+bns; while(Ans&lt;ans)Ans+=lcm; return Ans; } int main(){ freopen(&quot;dragon.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dragon.out&quot;,&quot;w&quot;,stdout); long long t; scanf(&quot;%lld&quot;,&amp;t); while(t--){ clear(); printf(&quot;%lld\\n&quot;,solve()); // return 0; } } 题目链接： 「NOI2018」屠龙勇士","path":"2018/07/20/NOI2018-屠龙勇士/"},{"title":"Milk Patterns","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define hash 19260817 #define N 22000 using namespace std; typedef unsigned long long ull; ull h[N]; int n,k,a[N]; map&lt;ull,int&gt;p; int print(int x,int y){ for(int i=x;i&lt;=y;i++)printf(&quot;%d &quot;,a[i]); } bool check(int l){ p.clear(); if(l==0)return true; ull o=0; for(int i=1;i&lt;=l;i++) o*=hash,o+=a[i]; // print(1,l); // printf(&quot; %llu \\n&quot;,o); p[o]=1; for(int i=1;i&lt;=n-l;i++){ o-=h[l-1]*a[i]; o*=hash; o+=a[i+l]; // print(i+1,i+l); // printf(&quot; %llu \\n&quot;,o); if(++p[o]&gt;=k)return true; } return false; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); h[0]=1; for(int i=1;i&lt;=n;i++)h[i]=h[i-1]*hash; int l=0,r=n; // printf(&quot;%d\\n&quot;,check(9)); while(r-l&gt;4){ int m=(l+r)/2; if(check(m))l=m; else r=m-1; } for(int i=r;i&gt;=l;i--){ if(check(i)){ printf(&quot;%d\\n&quot;,i); return 0; } } } 题目链接：Milk Patterns","path":"2018/07/19/奶牛质量/"},{"title":"Race","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 420000 using namespace std; int h[N],v[N],w[N],Next[N],q[N],p[N],siz[N],son[N],s[N*10]; int dep[N],l[N],tot,k,n,ans,head,tail; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int solve(int x,int fa){ if(l[x]&gt;k){ l[x]=0; return 0; } if(l[x]==k)ans=min(ans,dep[x]-1); q[++tail]=x; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; if(v[i]==fa)continue; l[v[i]]=l[x]+w[i]; solve(v[i],x); } return ans; } int pre(int x,int fa){ siz[x]=1; dep[x]=dep[fa]+1; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; if(v[i]==fa)continue; pre(v[i],x); siz[x]=siz[x]+siz[v[i]]; } } int get_son(int x,int fa,int ooo){ son[x]=ooo-siz[x]; int ans=0,bns; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; if(v[i]==fa)continue; bns=get_son(v[i],x,ooo); son[x]=max(son[x],siz[v[i]]); if(ans==0)ans=bns; else{ if(son[bns]&lt;son[ans])ans=bns; } } if(son[x]&lt;son[ans])ans=x; if(ans==0)ans=x; return ans; } int dfs(int x){ p[x]=1; pre(x,0); head=0,tail=0; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; l[v[i]]=l[x]+w[i]; solve(v[i],x); for(int j=head+1;j&lt;=tail;j++)if(s[k-l[q[j]]]){ ans=min(ans,s[k-l[q[j]]]+dep[q[j]]-2); } for(int j=head+1;j&lt;=tail;j++){ if(s[l[q[j]]])s[l[q[j]]]=min(s[l[q[j]]],dep[q[j]]); else s[l[q[j]]]=dep[q[j]]; } head=tail; } for(int i=1;i&lt;=tail;i++)s[l[q[i]]]=0,l[q[i]]=0,dep[q[i]]=0; for(int i=h[x];i;i=Next[i]){ if(p[v[i]]==1)continue; dfs(get_son(v[i],0,siz[v[i]])); } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;n;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); x++;y++; add(x,y,z); add(y,x,z); } ans=0x7fffffff; dfs(1); if(ans&gt;n)printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,ans); } 题目链接：Race","path":"2018/07/19/点分x/"},{"title":"PRZ","text":"#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int n,W; int w[18],t[18]; int f[1&lt;&lt;16],sum[1&lt;&lt;16],l[1&lt;&lt;16]; int main(){ scanf(&quot;%d%d&quot;,&amp;W,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d%d&quot;,&amp;t[i],&amp;w[i]); for(int i=1;i&lt;(1&lt;&lt;n);i++){ for(int j=1;j&lt;=n;j++){ if(i&gt;&gt;(j-1)&amp;1){ sum[i]+=w[j]; l[i]=max(l[i],t[j]); } } } memset(f,0x7f,sizeof(f)); f[0]=0; for(int i=1;i&lt;(1&lt;&lt;n);i++){ for(int j=i;j;j=i&amp;(j-1)) if(sum[j]&lt;=W)f[i]=min(f[i],l[j]+f[i^j]); } printf(&quot;%d\\n&quot;,f[(1&lt;&lt;n)-1]); } 题目链接：PRZ","path":"2018/07/19/雪崩/"},{"title":"NOI 2018归程","text":"题解： 直接上可持久化并查集两个log(机房里有人爆碾过去了，然而我常数超大，被卡了两个点qwq)。（SPFA被卡教你做人（本地十三秒的大数据SPFA跑了十一秒……）） 强烈谴责施工团队，获得成就，在工地里打noi同步赛（正下方拆地板……）。B的44暴力和C的60多的暴力在口头糊出来了，然而我逃到四楼去写题里面有人特别吵，完全无法集中注意力（一个弱智A题写了两个多小时）（虽然好像是甩锅，不过外界因素对我的影响确实有点大，属于那种环境稍微炸点就自闭的选手qwq）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #define N 3200000 #define M 12000000 #define pa pair&lt;int,int&gt; using namespace std; struct node{ int x,y,l,a;//l长度 a海拔 }a[N]; struct illyasviel{ int p,c,id;//c出发节点 p海拔高度 }b[N]; int h[N],v[N],Next[N],d[N],l[N],p[N],w[N]; int tot,n,m,Q; bool cmp(node x,node y){ return x.a&gt;y.a; } bool cmp1(illyasviel x,illyasviel y){ return x.p&gt;y.p; } struct bing{ int sz; int root[N],ls[M],rs[M],v[M],deep[M],dd[M]; int clear(){ sz=0; memset(root,0,sizeof(root)); memset(deep,0,sizeof(deep)); memset(ls,0,sizeof(ls)); memset(rs,0,sizeof(rs)); memset(dd,0,sizeof(dd)); memset(rs,0,sizeof(rs)); memset(v,0,sizeof(v)); } void build(int &amp;k,int l,int r){ if(!k)k=++sz; if(l==r){v[k]=l;dd[k]=d[l];return;} int mid=(l+r)&gt;&gt;1; build(ls[k],l,mid); build(rs[k],mid+1,r); } void modify(int l,int r,int x,int &amp;y,int pos,int val,int bal){ y=++sz; if(l==r){v[y]=val;dd[y]=bal;deep[y]=deep[x];return;} ls[y]=ls[x];rs[y]=rs[x]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(l,mid,ls[x],ls[y],pos,val,bal); else modify(mid+1,r,rs[x],rs[y],pos,val,bal); } int query(int k,int l,int r,int pos){ if(l==r)return k; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)return query(ls[k],l,mid,pos); else return query(rs[k],mid+1,r,pos); } void add(int k,int l,int r,int pos){ if(l==r){deep[k]++;return;} int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)add(ls[k],l,mid,pos); else add(rs[k],mid+1,r,pos); } int find(int k,int x){ int p=query(k,1,n,x); if(x==v[p])return p; return find(k,v[p]); } int bin(int a,int b,int i){ root[i+n]=root[i-1]; root[i]=root[i-1]; int p=find(root[i],a),q=find(root[i],b); if(v[p]==v[q])return 0; if(deep[p]&gt;deep[q])swap(p,q); modify(1,n,root[i-1],root[i+n],v[q],v[q],min(dd[p],dd[q])); modify(1,n,root[i+n],root[i],v[p],v[q],min(dd[p],dd[q])); if(deep[p]==deep[q])add(root[i],1,n,v[q]); } int get(int rt,int a){ return dd[find(rt,a)]; } }sb; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; tot++; Next[tot]=h[y]; v[tot]=x; w[tot]=z; h[y]=tot; } int find(int x){ int ll=0,r=m; while(r-ll&gt;5){ int mid=(ll+r)/2; if(l[mid]&gt;x)ll=mid; else r=mid-1; } for(int i=r;i&gt;=ll;i--){ if(l[i]&gt;x)return i; } return ll; } void dijkstra() { priority_queue&lt;pa,vector&lt;pa&gt;,greater&lt;pa&gt; &gt;q; memset(d,0x7f,sizeof(d)); d[1]=0;q.push(make_pair(0,1)); while(!q.empty()){ int now=q.top().second;q.pop(); for(int i=h[now];i;i=Next[i]) if(d[now]+w[i]&lt;d[v[i]]){ d[v[i]]=d[now]+w[i]; q.push(make_pair(d[v[i]],v[i])); } } } int main(){ freopen(&quot;return.in&quot;,&quot;r&quot;,stdin); freopen(&quot;return.out&quot;,&quot;w&quot;,stdout); int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ sb.clear(); tot=0; memset(h,0,sizeof(h)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(d,0x7f,sizeof(d)); d[1]=0; for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].l,&amp;a[i].a); for(int i=1;i&lt;=m;i++)add(a[i].x,a[i].y,a[i].l); sort(a+1,a+1+m,cmp); dijkstra(); sb.build(sb.root[0],1,n); for(int i=1;i&lt;=m;i++){ sb.bin(a[i].x,a[i].y,i); // for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,sb.v[sb.find(sb.root[i],j)]); // for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,sb.dd[sb.find(sb.root[i],j)]); // printf(&quot;\\n&quot;); } // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,d[i]); // printf(&quot;\\n&quot;); for(int i=1;i&lt;=m;i++)l[i]=a[i].a; l[0]=0x7fffffff; int k,s; scanf(&quot;%d%d%d&quot;,&amp;Q,&amp;k,&amp;s); int lastans=0; for(int i=1;i&lt;=Q;i++){ int x,p; scanf(&quot;%d %d&quot;,&amp;x,&amp;p); x=(x+k*lastans-1)%n+1; p=(p+k*lastans)%(s+1); int o=find(p); lastans=sb.dd[sb.find(sb.root[o],x)]; // printf(&quot;%d %d %d %d\\n&quot;,o,x,p,lastans); printf(&quot;%d\\n&quot;,lastans); } // solve2(); } } 题目链接：「NOI2018」归程","path":"2018/07/17/NOI2018-归程/"},{"title":"征服王","text":"题目大意： 求最小可重复多起点多终点路径覆盖。 题解： tarjan缩点后，费用流然后计算增广次数即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #define inf 0x7fffffff using namespace std; int S,T; int n,m,A,B,tot; int ind,top,scc,cost,ans; int dfn[1005],low[1005],bl[1005]; int a[1005],b[1005]; int d[2005],q[2005]; bool mark[2005],inq[1005]; int Next[120000],c[120000],v[120000],w[120000],h[120000]; vector&lt;int&gt;e[120000]; void add(int x,int y,int W,int C){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=W; c[tot]=C; h[x]=tot; tot++; Next[tot]=h[y]; v[tot]=x; w[tot]=0; c[tot]=-C; h[y]=tot; } void tarjan(int x){ low[x]=dfn[x]=++ind; q[++top]=x;inq[x]=1; for(int i=0;i&lt;e[x].size();i++) if(!dfn[e[x][i]]){ tarjan(e[x][i]); low[x]=min(low[x],low[e[x][i]]); } else if(inq[e[x][i]])low[x]=min(low[x],dfn[e[x][i]]); if(low[x]==dfn[x]){ int now=0;scc++; while(now!=x){ now=q[top--];inq[now]=0; bl[now]=scc; } } } bool spfa(){ memset(mark,0,sizeof(mark)); for(int i=0;i&lt;=S;i++)d[i]=-1; int head=0,tail=1; q[0]=T;d[T]=0;mark[T]=1; while(head!=tail){ int now=q[head];head++;if(head&gt;2000)head=0; mark[now]=0; for(int i=h[now];i;i=Next[i]) if(w[i^1]&amp;&amp;d[now]+c[i^1]&gt;d[v[i]]){ d[v[i]]=d[now]+c[i^1]; if(!mark[v[i]]){ mark[v[i]]=1; q[tail++]=v[i]; if(tail&gt;2000)tail=0; } } } return d[S]!=-1; } int dfs(int x,int f){ mark[x]=1; if(x==T)return f; int W,used=0; for(int i=h[x];i;i=Next[i]) if(!mark[v[i]]&amp;&amp;w[i]&amp;&amp;d[x]-c[i]==d[v[i]]){ W=dfs(v[i],min(w[i],f-used)); w[i]-=W;w[i^1]+=W;cost+=c[i]*W; used+=W; if(used==f)return f; } return used; } void solve(){ tot=1; T=2*scc+1;S=T+1; for(int i=1;i&lt;=A;i++)add(0,bl[a[i]],inf,0); for(int i=1;i&lt;=B;i++)add(bl[b[i]]+scc,T,inf,0); for(int x=1;x&lt;=n;x++) for(int i=0;i&lt;e[x].size();i++) if(bl[x]!=bl[e[x][i]]) add(bl[x]+scc,bl[e[x][i]],inf,0); for(int i=1;i&lt;=scc;i++){ add(i,i+scc,1,1); add(i,i+scc,inf,0); } add(S,0,1,0); while(spfa()){ int pre=cost; mark[T]=1; while(mark[T]){ memset(mark,0,sizeof(mark)); dfs(S,inf); } add(S,0,1,0); if(pre==cost)break; else ans++; } } int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ memset(h,0,sizeof(h)); memset(dfn,0,sizeof(dfn)); ans=scc=cost=ind=tot=0; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;A,&amp;B); for(int i=1;i&lt;=100000;i++)e[i].clear(); for(int i=1;i&lt;=A;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=B;i++)scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=m;i++){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); e[u].push_back(v); } for(int i=1;i&lt;=n;i++) if(!dfn[i])tarjan(i); solve(); if(cost!=scc)puts(&quot;no solution&quot;); else printf(&quot;%d\\n&quot;,ans); } return 0; }","path":"2018/07/17/征服王/"},{"title":"相似字串","text":"题目大意： 求本质不同的第i小和第j小的字符串的最长公共共前缀与后缀。 题解： 用sa还原位置然后st表求前缀，后缀的话在反串的后缀数组再做一次即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define N 120000 #define fo(i,j,k) for(i=j;i&lt;=k;i++) using namespace std; int m,q; char s[N]; long long cnt[N]; long long sum,n; struct SA{ int st[N][30],rk[N],he[N]; int b[N],x[N],y[N],sa[N],m=128; char a[N];inline bool comp(int i,int j,int l) { return y[i]==y[j]&amp;&amp;(i+l&gt;n?-1:y[i+l])==(j+l&gt;n?-1:y[j+l]); } inline void work() { int i,j,k,p;m=128; fo(i,0,m) b[i]=0; fo(i,1,n) b[x[i]=a[i]]++; fo(i,1,m) b[i]+=b[i-1]; for(i=n;i&gt;=1;i--) sa[b[x[i]]--]=i; for(k=1;k&lt;=n;k&lt;&lt;=1) { p=0; fo(i,n-k+1,n) y[++p]=i; fo(i,1,n) if(sa[i]&gt;k) y[++p]=sa[i]-k; fo(i,0,m) b[i]=0; fo(i,1,n) b[x[y[i]]]++; fo(i,1,m) b[i]+=b[i-1]; for(i=n;i&gt;=1;i--) sa[b[x[y[i]]]--]=y[i]; swap(x,y),p=2,x[sa[1]]=1; fo(i,2,n) x[sa[i]]=comp(sa[i-1],sa[i],k)?p-1:p++; if(p&gt;n) break; m=p; } p=k=0; fo(i,1,n) rk[sa[i]]=i; for(i=1;i&lt;=n;he[rk[i++]]=k) for(k?k--:0,j=sa[rk[i]-1];a[i+k]==a[j+k];k++); } int init(){ for(int i=1;i&lt;=n;i++)st[i][0]=he[i]; for(int j=1;j&lt;=29;j++) for(int i=1;i&lt;=n;i++) if((i+(1&lt;&lt;j)-1)&lt;=n)st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;j-1)][j-1]); } int lcp(int x,int y){ if(x==y)return n-x+1; x=rk[x],y=rk[y]; if(x&gt;y)swap(x,y); x++; int k=0; while(x+(1&lt;&lt;k+1)&lt;=y)k++; return min(st[x][k],st[y-(1&lt;&lt;k)+1][k]); } }A,B; int main(){ //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++)A.a[i]=s[i]; for(int i=1;i&lt;=n;i++)B.a[i]=s[n-i+1]; A.work(),A.init(); B.work(),B.init(); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,B.rk[i]); for(int i=1;i&lt;=n;i++)cnt[i]=cnt[i-1]+(n-A.sa[i]+1-A.he[i]); sum=cnt[n]; while(q--){ long long l,r; scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r); if(l&gt;sum||r&gt;sum){ printf(&quot;-1\\n&quot;); continue; } int lx=lower_bound(cnt+1,cnt+n+1,l)-cnt; int rx=lower_bound(cnt+1,cnt+n+1,r)-cnt; int L=l-cnt[lx-1]+A.sa[lx]+A.he[lx]-1; int R=r-cnt[rx-1]+A.sa[rx]+A.he[rx]-1; long long AA=min(A.lcp(A.sa[lx],A.sa[rx]),min(L-A.sa[lx]+1,R-A.sa[rx]+1)); long long BB=min(B.lcp(n-L+1,n-R+1),min(L-A.sa[lx]+1,R-A.sa[rx]+1)); BB=max(BB,(B.a[n-L+1]==B.a[n-R+1])?1LL:0LL); printf(&quot;%lld\\n&quot;,AA*AA+BB*BB); } } 原题链接：相似字串","path":"2018/07/17/相似字串/"},{"title":"Find the outlier","text":"题目大意： Abacus教授刚刚完成了一个制作数表的计算引擎的设计。它被设计用于同时计算一个多项式在许多点的取值。例如对于多项式f(x)=x2+2x+1f(x)=x^2+2x+1f(x)=x​2​​+2x+1，一种可能的计算结果是 f(0)=1,f(1)=4,f(2)=9.f(3)=16,f(4)=25f(0)=1,f(1)=4,f(2)=9.f(3)=16,f(4)=25f(0)=1,f(1)=4,f(2)=9.f(3)=16,f(4)=25 。不幸的是，引擎存在一个故障使得计算出的值总有一个是错的，例如对于上述多项式，它可能输出 1,4,12,16,251,4,12,16,251,4,12,16,25 而不是 1,4,9,16,251,4,9,16,251,4,9,16,25 。请你帮教授找出发生故障的是哪个点值。 题解： 暴力高斯消元检验即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #define N 22 #define eps 1e-3 using namespace std; double g[N][N],p[N][N],f[N][N]; int tot; int n; int gass(int n,int o){ for(int i=1;i&lt;=n;i++){ if(fabs(g[i][i])&lt;eps){ for(int j=1;j&lt;=n;j++){ if(g[j][i]){ for(int k=1;k&lt;=n;k++)swap(g[j][k],g[i][k]); break; } } } for(int j=1;j&lt;=n+1;j++){ if(i==j)continue; double l=g[j][i]/g[i][i]; for(int k=1;k&lt;=n+1;k++){ g[j][k]+=-l*g[i][k]; } } } for(int i=1;i&lt;=n;i++)p[o][i]=g[i][n+1]/g[i][i]; } bool check(int x){ int o=0; memset(p,0,sizeof(p)); for(int i=0;i&lt;n+3;i++){ if(i==x)continue; memset(g,0,sizeof(g)); tot=0; ++o; for(int j=0;j&lt;n+3;j++){ if(j==x)continue; if(j==i)continue; ++tot; for(int k=0;k&lt;n+3;k++)g[tot][k+1]=f[j][k]; } gass(n+1,o); if(o==1)continue; for(int j=1;j&lt;=n+1;j++) if(fabs(p[o][j]-p[o-1][j])&gt;eps)return false; } return true; } int main(){ while(1){ scanf(&quot;%d&quot;,&amp;n); if(n==0)return 0; for(int i=0;i&lt;n+3;i++){ scanf(&quot;%lf&quot;,&amp;f[i][n+1]); f[i][0]=1; for(int j=1;j&lt;=n;j++)f[i][j]=pow(i,j); } for(int i=0;i&lt;n+3;i++) if(check(i)){ printf(&quot;%d\\n&quot;,i); break; } // return 0; } } 原题链接：Find the outlier","path":"2018/07/17/Find-the-outlier异常/"},{"title":"大包子的完美组合","text":"题目大意： 大包子的公司有n个人，编号分别为1至n。年底，大包子将要举办一场舞会，大包子要从中选出一些人参加这个舞会。 如果选出的这些人中，编号两两互质，我们就认为这是一个完美组合。比如 5 个人的公司中，3, 4, 5这三个人可以组成完美组合。请计算n个人可以选出的完美组合的方案数。 由于答案很大，你需要把答案对109+710^9+710​9​​+7取模。 题解： 首先，我们先把n\\sqrt{n}√​n​​​的素数筛出来，只有16个。 首先我们把1到3000根据该数的最大质因子排序。 我们对小于n\\sqrt{n}√​n​​​ 的素数做状压 DP ，每一位存当前该素数是否被取用过。 对于大于 n\\sqrt{n}√​n​​​的素数，我们发现同一个数中不可能存在两个大于n\\sqrt{n}√​n​​​的因子，因此我们枚举每个素数，枚举最大质因子是这个素数的数，做一次状压 DP ，再记录一维表示这个大素数是否被取用。 将最终答案减去空集。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define P 1000000007 #define M 3200 #define K 16 using namespace std; int prime[K]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53}; int n; int f[2][1&lt;&lt;K][2]; struct node{int max,sc;}a[M]; int cmp(node x,node y){ if(x.max!=y.max) return x.max&lt;y.max; if(x.sc!=y.sc) return x.sc&lt;y.sc; } int cut(int x){ int ans=0; for(int j=0;j&lt;K;j++) if(x%prime[j]==0) ans|=1&lt;&lt;j; return ans; } int main(void){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ a[i].max=i; a[i].sc=1; for(int j=0;j&lt;K;j++) while(a[i].max%prime[j]==0) {a[i].max/=prime[j];a[i].sc*=prime[j];} } sort(a+1,a+n+1,cmp); f[0][0][0]=1; int p=0; for(int i=1;i&lt;=n;i++){ if(a[i].max!=a[i-1].max) for(int j=0;j&lt;1&lt;&lt;K;j++) (f[p][j][0]+=f[p][j][1])%=P,f[p][j][1]=0; p^=1; for(int j=0;j&lt;1&lt;&lt;K;j++) f[p][j][0]=f[p^1][j][0],f[p][j][1]=f[p^1][j][1]; int is=a[i].max&gt;1; int tmp=cut(a[i].sc); for(int j=(1&lt;&lt;K)-1;j&gt;=0;j--) if( f[p^1][j][0]&amp;&amp;!(j&amp;tmp) ) (f[p][j|tmp][is]+=f[p^1][j][0])%=P; } int ans=0; for(int i=0;i&lt;1&lt;&lt;K;i++) for(int j=0;j&lt;=1;j++) (ans+=f[p][i][j])%=P; (ans+=P-1)%=P; printf(&quot;%d\\n&quot;,ans); } 原题链接：大包子的完美组合","path":"2018/07/16/大包子的完美组合/"},{"title":"等差子序列","text":"题目大意： 给一个1到N的排列{A_i}，询问是否存在1≤p1&lt;p2&lt;p3&lt;p4&lt;p5&lt;...&lt;pLen≤N(Len≥3)1\\leq p_1&lt;p_2&lt;p_3&lt;p_4&lt;p_5&lt;...&lt;p_{Len}\\leq N (Len\\geq 3)1≤p​1​​&lt;p​2​​&lt;p​3​​&lt;p​4​​&lt;p​5​​&lt;...&lt;p​Len​​≤N(Len≥3)， 使得Ap1,Ap2,Ap3,...ApLenA_{p1},A{p2},A{p3},...A{pLen}A​p1​​,Ap2,Ap3,...ApLen是一个等差序列。 题解： 树状数组维护hash值。 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;stdio.h&gt; #define N 120000 #define P 1000000007 #define lowbit(x) (x&amp;-x) using namespace std; int n,pw[N],a[N]; struct node{ long long a[N]; int add(int x,int b){ for(int i=x;i&lt;=n;i+=lowbit(i))(a[i]+=b)%=P; } long long sum(int x){ long long ans=0; for(int i=x;i&gt;0;i-=lowbit(i))(ans+=a[i])%=P; return ans; } int clear(){ memset(a,0,sizeof(a)); } }L,R; long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int main(){ int T; pw[0]=1; scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=N-10;i++)pw[i]=pw[i-1]*2%P; while(T--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); bool ans=false; L.clear(); R.clear(); for(int i=1;i&lt;=n;i++){ int o=a[i]; L.add(o,pw[o]); R.add(n-o+1,pw[n-o+1]); if(o&lt;=n/2) if(L.sum(o-1)!=((R.sum(n-o)-R.sum(n-o-o+1))*power(pw[n-o-o+1],P-2)%P+P)%P){ ans=true; break; } if(o&gt;n/2) if(((L.sum(o-1)-L.sum(o-1-(n-o)))*power(pw[o-1-(n-o)],P-2)%P+P)%P!=R.sum(n-o)){ ans=true; break; } } if(ans)printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } } 原题链接：等差子序列","path":"2018/07/16/等差子序列/"},{"title":"普通平衡树","text":"题目大意： 1、插入xx数 2、删除xx数（若有多个相同的数，因只删除一个） 3、查询xx数的排名（若有多个相同的数，因输出最小的排名） 4、查询排名为xx的数 5、求xx的前驱（前驱定义为小于xx，且最大的数） 6、求xx的后继（后继定义为大于xx，且最小的数） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define lc(x) (ch[x][0]) #define rc(x) (ch[x][1]) #define N 120000 using namespace std; int sum[N],ch[N][2],fa[N],val[N],cnt[N],o; int n,root,tot; int update(int x){ sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+cnt[x]; } int rotate(int x,int a){ int Fa=fa[x]; if(fa[Fa])ch[fa[Fa]][ch[fa[Fa]][1]==Fa]=x; fa[x]=fa[Fa]; fa[Fa]=x; if(ch[x][a])fa[ch[x][a]]=Fa; ch[Fa][a^1]=ch[x][a]; ch[x][a]=Fa; update(Fa); update(x); } int splay(int x,int y){ while(fa[x]!=y){ int Fa=fa[x]; if(ch[fa[x]][1]==x){ if(fa[Fa]!=y&amp;&amp;ch[fa[Fa]][1]==Fa)rotate(Fa,0); rotate(x,0); }else{ if(fa[Fa]!=y&amp;&amp;ch[fa[Fa]][0]==Fa)rotate(Fa,1); rotate(x,1); } } if(y==0)root=x; return root; }int insert(int rt,int x,int Fa){ if(!rt){ tot++; val[tot]=x; sum[tot]++; cnt[tot]++; fa[tot]=Fa; o=tot; return tot; } if(x&lt;val[rt])ch[rt][0]=insert(ch[rt][0],x,rt); if(x&gt;val[rt])ch[rt][1]=insert(ch[rt][1],x,rt); if(x==val[rt])cnt[rt]++,o=rt; update(rt); return rt; } int ins(int x){ insert(root,x,0); splay(o,0); } int delet(int rt,int x){ if(x&gt;val[rt])delet(rc(rt),x); if(x&lt;val[rt])delet(lc(rt),x); if(x==val[rt]){ o=rt; if(cnt[rt])cnt[rt]--; } update(rt); } int del(int x){ delet(root,x); if(cnt[o])return 0; splay(o,0); int l=rc(o); int k=lc(o); while(lc(l))l=lc(l); while(rc(k))k=rc(k); splay(k,0); splay(l,k); l=rc(k); while(lc(l))l=lc(l); ch[fa[l]][rc(fa[l])==l]=0; fa[l]=0; } int find(int rt){ int x=ch[rt][0]; while(ch[x][1])x=ch[x][1]; return val[x]; } int kind(int rt){ int x=ch[rt][1]; while(ch[x][0])x=ch[x][0]; return val[x]; } int get(int rt,int x){ if(sum[ch[rt][0]]&lt;x-1&amp;&amp;sum[ch[rt][0]]+cnt[rt]&gt;x-1)return val[rt]; if(sum[ch[rt][0]]&gt;x-1)return get(ch[rt][0],x); if(sum[ch[rt][0]]&lt;x-1)return get(ch[rt][1],x-sum[ch[rt][0]]-cnt[rt]); return val[rt]; } int want(int rt,int x){ if(x&lt;val[rt])return want(ch[rt][0],x); if(x&gt;val[rt])return want(ch[rt][1],x); return rt; } int main(){ scanf(&quot;%d&quot;,&amp;n); int inf=2147483647; ins(inf); ins(-inf); for(int i=1;i&lt;=n;i++){ int type,x; scanf(&quot;%d%d&quot;,&amp;type,&amp;x); if(type==1)ins(x); if(type==2)del(x); if(type==3){ splay(want(root,x),0); printf(&quot;%d\\n&quot;,sum[ch[root][0]]); } if(type==4){ printf(&quot;%d\\n&quot;,get(root,x+1)); } if(type==5){ ins(x); printf(&quot;%d\\n&quot;,find(root)); del(x); } if(type==6){ ins(x); printf(&quot;%d\\n&quot;,kind(root)); del(x); } } } 原题链接：【BZOJ3224】【TYVJ1728】普通平衡树","path":"2018/07/16/splay板子/"},{"title":"k个串 kstring","text":"题目大意： 兔子们在玩k个串的游戏。首先，它们拿出了一个长度为n的数字序列，选出其中的一个连续子串，然后统计其子串中所有数字之和（注意这里重复出现的数字只被统计一次）。 兔子们想知道，在这个数字序列所有连续的子串中，按照以上方式统计其所有数字之和，第k大的和是多少。 题解： 考虑每次加入一个右端点，只有preaipre_{a_{i}}pre​a​i​​​​到i上的值会增加aia_ia​i​​，对于每个右端点维护一颗可持久化线段树，这样我们可以快速得到每个右端点的区间最大值。 然后将每个右端点加入优先队列，(v,l,r,p,x)(x表示当前树根（既哪个右端点），lr表示当前区间，p表示在l到r中的最大值是多少，v表示当前最大值)，每次拔出堆顶然后分裂区间后顶进去，重复k次后就能得到最大值。 失分原因： NM打反，导致线段树节点数不够。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #include&lt;queue&gt; #define N 120000 #define M 7200000 using namespace std; struct illyasviel{ long long x,y; }v[N]; illyasviel get(long long x,long long y){ illyasviel ans; ans.x=x; ans.y=y; return ans; } illyasviel max(illyasviel x,illyasviel y){ if(x.x==y.x){ if(x.y&lt;y.y)return y; return x; } if(x.x&gt;y.x)return x; return y; } int n,m; int tot,rt[N],lc[M],rc[M]; long long tag[M]; map&lt;int,int&gt;pre; struct node{ long long v,x,l,r,now; friend bool operator &lt; (const node &amp;a,const node &amp;b){return a.v&lt;b.v;} }; node get(long long v,int x,int l,int r,int now){ node ans; ans.v=v; ans.x=x; ans.l=l; ans.r=r; ans.now=now; return ans; } priority_queue&lt;node&gt;q; int build(int l,int r){ int x=++tot;v[x]=get(0,l); if(l==r)return x; int mid=l+r&gt;&gt;1; lc[x]=build(l,mid); rc[x]=build(mid+1,r); return x; } int add(int y,long long p){ int x=++tot; lc[x]=lc[y]; rc[x]=rc[y]; v[x]=v[y]; v[x].x+=p; tag[x]=tag[y]+p; return x; } int pushdown(int x){ lc[x]=add(lc[x],tag[x]); rc[x]=add(rc[x],tag[x]); tag[x]=0; } int insert(int y,int l,int r,int ll,int rr,int p){ if(ll&lt;=l&amp;&amp;r&lt;=rr)return add(y,p); if(tag[y])pushdown(y); int x=++tot;lc[x]=lc[y],rc[x]=rc[y],v[x]=v[y]; int mid=l+r&gt;&gt;1; if(ll&lt;=mid)lc[x]=insert(lc[y],l,mid,ll,rr,p); if(rr&gt;mid)rc[x]=insert(rc[y],mid+1,r,ll,rr,p); v[x]=max(v[lc[x]],v[rc[x]]); return x; } illyasviel query(int x,int l,int r,int ll,int rr){ if(ll&lt;=l&amp;&amp;rr&gt;=r)return v[x]; if(tag[x])pushdown(x); int mid=l+r&gt;&gt;1; illyasviel ans; ans.x=-1e15;ans.y=-1e15; if(ll&lt;=mid)ans=max(ans,query(lc[x],l,mid,ll,rr)); if(rr&gt;mid)ans=max(ans,query(rc[x],mid+1,r,ll,rr)); return ans; } int add(int x,int l,int r){ if(l&gt;r)return 0; illyasviel t=query(x,1,n,l,r); q.push(get(t.x,x,l,r,t.y)); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt[0]=build(1,n); for(int i=1;i&lt;=n;i++){ int x; scanf(&quot;%d&quot;,&amp;x); rt[i]=insert(rt[i-1],1,n,pre[x]+1,i,x); pre[x]=i; add(rt[i],1,i); } node x; for(int i=1;i&lt;=m;i++){ x=q.top();q.pop(); add(x.x,x.l,x.now-1); add(x.x,x.now+1,x.r); } printf(&quot;%lld&quot;,x.v); } 原题链接：k个串 kstring","path":"2018/07/16/k个串-kstring/"},{"title":"次小生成树 tree","text":"题目大意： 求一个严格的次小生成树。 题解： 先求出最小生成树，然后对于每一条非最小生成树上的边都求出将这条边加入最小生成树中增大的最小代价，最后统计答案即可。（求代价时可用倍增求出链上最大值和次大值（次大值是为了保证是严格的最小生成树）） 不知道为什么sort来合并比O(1)合并快两倍…… #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 620000 using namespace std; int fa[N],Next[N],v[N],h[N],w[N],tot,f[N/6][21],dep[N/6],c[N]; int b[5],n,m; struct node{ int x,y,z; }a[N]; struct illyasviel{ int x,y; int clear(){x=0,y=0;} }g[N/6][21]; bool cmp(node x,node y){ return x.z&lt;y.z; } int find(int x){ if(fa[x]==x)return x; return fa[x]=find(fa[x]); } int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } illyasviel merge(illyasviel x,illyasviel y){ illyasviel ans; ans.clear(); b[1]=x.x; b[2]=x.y; b[3]=y.x; b[4]=y.y; sort(b+1,b+1+4); ans.x=b[4]; for(int i=1;i&lt;=3;i++)if(b[i]&lt;b[4])ans.y=b[i]; return ans; } int dfs(int x,int fa){ dep[x]=dep[fa]+1; f[x][0]=fa; for(int i=1;i&lt;=20;i++)f[x][i]=f[f[x][i-1]][i-1]; for(int i=1;i&lt;=20;i++)g[x][i]=merge(g[x][i-1],g[f[x][i-1]][i-1]); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; g[v[i]][0].x=w[i]; dfs(v[i],x); } } illyasviel lca(int x,int y){ illyasviel ans; ans.clear(); if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i&gt;=0;i--)if(dep[f[x][i]]&gt;=dep[y])ans=merge(g[x][i],ans),x=f[x][i]; if(x==y)return ans; for(int i=20;i&gt;=0;i--){ if(f[x][i]!=f[y][i]){ ans=merge(ans,g[x][i]); ans=merge(ans,g[y][i]); x=f[x][i];y=f[y][i]; } } ans=merge(ans,g[x][0]); ans=merge(ans,g[y][0]); return ans; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); } long long ans=0; for(int i=1;i&lt;=n;i++)fa[i]=i; sort(a+1,a+1+m,cmp); int oo=0; for(int i=1;i&lt;=m;i++){ if(find(a[i].x)!=find(a[i].y)){ c[i]=1; ans+=0LL+a[i].z; fa[find(a[i].x)]=find(a[i ].y); add(a[i].x,a[i].y,a[i].z); add(a[i].y,a[i].x,a[i].z); oo=max(a[i].z,oo); } } dfs(1,0); long long bns=0x7fffffff; for(int i=1;i&lt;=m;i++){ if(a[i].z-oo&gt;=bns)continue; if(c[i]==0){ illyasviel p=lca(a[i].x,a[i].y); bns=min(bns,(a[i].z-p.x&gt;0)?0LL+a[i].z-p.x:0LL+a[i].z-p.y); } } printf(&quot;%lld\\n&quot;,ans+bns); } 原题链接：次小生成树 Tree","path":"2018/07/16/次小生成树-tree/"},{"title":"gcd","text":"题目大意： 对于给出的n个询问，每次求有多少个数对(x,y)(x,y)(x,y)，满足a≤x≤ba\\leq x\\leq ba≤x≤b，c≤y≤dc\\leq y\\leq dc≤y≤d，且gcd(x,y)=kgcd(x,y)=kgcd(x,y)=k，gcd(x,y)gcd(x,y)gcd(x,y)函数为x和y的最大公约数。 题解： 莫比乌斯反演 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int p[N],prime[N],mu[N],f[N],tot; int pre(){ mu[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0)prime[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0){ mu[i*prime[j]]=0; break; } } } for(int i=1;i&lt;=N-10;i++)f[i]=f[i-1]+mu[i]; } long long cal(int n,int m){ long long ans=0; if(n*m==0)return 0; if(n&gt;m)swap(n,m); for(int i=1;i&lt;=n;i++){ int j=min(n/(n/i),m/(m/i)); ans+=1LL*(n/i)*(m/i)*(f[j]-f[i-1]); i=j; } // printf(&quot;%d %d %d\\n&quot;,n,m,ans); return ans; } int main(){ int n; pre(); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int a,b,c,d,k; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf(&quot;%lld\\n&quot;,cal(b/k,d/k)-cal(b/k,(c-1)/k)-cal((a-1)/k,d/k)+cal((a-1)/k,(c-1)/k)); } } 原题链接：gcd","path":"2018/07/16/弱智反演/"},{"title":"JSOI2008 火星人prefix","text":"题目大意： 求一个动态字符串的某两个位置的最长公共前缀。 题解： 用splay维护hash值然后二分长度即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 9875321 #define N 220000 using namespace std; char s[N],c[N]; int n,m; int p[N]; struct spaly{ int ch[N][2],id[N]; int fa[N],siz[N],v[N],hs[N]; int rt,tot; int update(int x){ int l=ch[x][0],r=ch[x][1]; siz[x]=siz[l]+siz[r]+1; hs[x]=(hs[l]+1LL*v[x]*p[siz[l]]%P+1LL*p[siz[l]+1]*hs[r]%P)%P; } int rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],l,r; if(ch[y][0]==x)l=0;else l=1;r=l^1; if(y==k)k=x; else {if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} fa[x]=z;fa[y]=x;fa[ch[x][r]]=y; ch[y][l]=ch[x][r];ch[x][r]=y; update(y);update(x); } int splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } int find(int x,int rk){ int l=ch[x][0],r=ch[x][1]; if(siz[l]+1==rk)return x; if(siz[l]+1&lt;rk)return find(r,rk-siz[l]-1); if(siz[l]+1&gt;rk)return find(l,rk); } int insert(int k,int val){ int x=find(rt,k+1),y=find(rt,k+2); splay(x,rt);splay(y,ch[x][1]); tot++;ch[y][0]=tot;fa[tot]=y;v[tot]=val; update(tot);update(y);update(x); } int query(int k,int val){ int x=find(rt,k),y=find(rt,k+val+1); splay(x,rt);splay(y,ch[x][1]); return hs[ch[y][0]]; } int solve(int x,int y){ int l=1,r=min(tot-x,tot-y)-1,ans=0; while(l&lt;=r){ int mid=(l+r)/2; if(query(x,mid)==query(y,mid)){l=mid+1;ans=mid;} else r=mid-1; } return ans; } void build(int l,int r,int f){ if(l&gt;r)return; int now=id[l],last=id[f]; if(l==r){ v[now]=hs[now]=c[l]-'a'+1; fa[now]=last;siz[now]=1; if(l&lt;f)ch[last][0]=now; else ch[last][1]=now; return; } int mid=(l+r)&gt;&gt;1;now=id[mid]; build(l,mid-1,mid);build(mid+1,r,mid); v[now]=c[mid]-'a'+1;fa[now]=last;update(now); if(mid&lt;f)ch[last][0]=now; else ch[last][1]=now; } }splay; int main(){ scanf(&quot;%s&quot;,c+2); n=strlen(c+2); p[0]=1;for(int i=1;i&lt;=150004;i++)p[i]=p[i-1]*27%P; for(int i=1;i&lt;=n+2;i++)splay.id[i]=i; splay.build(1,n+2,0);splay.tot=n+2;splay.rt=(n+3)&gt;&gt;1; scanf(&quot;%d&quot;,&amp;m); int x,y; char s[2],d[2]; for(int i=1;i&lt;=m;i++){ scanf(&quot;%s&quot;,s+1); scanf(&quot;%d&quot;,&amp;x); if(s[1]=='Q'){ scanf(&quot;%d&quot;,&amp;y); printf(&quot;%d\\n&quot;,splay.solve(x,y)); } if(s[1]=='R')scanf(&quot;%s&quot;,d+1),x=splay.find(splay.rt,x+1),splay.splay(x,splay.rt),splay.v[splay.rt]=d[1]-'a'+1,splay.update(splay.rt); if(s[1]=='I')scanf(&quot;%s&quot;,d+1),splay.insert(x,d[1]-'a'+1); } return 0; } 原题链接： JSOI2008火星人prefix","path":"2018/07/15/火星人/"},{"title":"Bracket","text":"题目大意： 现在有一个括号序列（不保证合法），你能够进行以下两个操作: 1：在任意位置加入一个左括号或者右括号 2：将序列最末的括号移到最前 现在想要知道，经过若干次操作后，得到的最短的字典序最小的括号序列是什么？ （“（”&lt;“）”） 题解： 通过旋转变换得到最小字典序的序列再在前后补足括号即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200000 #define getl(x) (-min(0,min(ms[x],msum[x-1]+sum2[x]))) using namespace std; int msum[N],ms[N],sum1[N],sum2[N]; int l,r,len,cl,cr,ans,minl,a[N]; char s[N]; int check(int l,int r,int ll,int rr){ for(int i=l;i&lt;=r;i++) if(s[i]=='('&amp;&amp;s[ll+i-l]==')')return 0;else if(s[i]==')'&amp;&amp;s[ll+i-l]=='(')return 1; return 0; } int main(){ scanf(&quot;%s&quot;,s+1); len=strlen(s+1); for(int i=1;i&lt;=len;i++) if(s[i]=='(')a[i]=1;else a[i]=-1; for(int i=1;i&lt;=len;i++){ s[i+len]=s[i]; a[i+len]=a[i]; } for(int i=1;i&lt;=len;i++){ sum1[i]=sum1[i-1]+a[i]; msum[i]=min(msum[i-1],sum1[i]); } for(int i=len;i;i--){ sum2[i]=sum2[i+1]+a[i]; ms[i]=min(ms[i+1]+a[i],a[i]); } minl=len; for(int i=1;i&lt;=len;i++)minl=min(minl,getl(i)); l=1,r=len; for(int i=1;i&lt;=len;i++)if(getl(i)==minl&amp;&amp;check(l,r,i,i+len-1))l=i,r=i+len-1; for(int i=1;i&lt;=minl;i++)printf(&quot;(&quot;); for(int i=l;i&lt;=r;i++)printf(&quot;%c&quot;,s[i]); for(int i=l;i&lt;=r;i++)if(s[i]=='(')cl++;else cr++; for(int i=cr;i&lt;cl;i++)printf(&quot;)&quot;); printf(&quot;\\n&quot;); } 原题链接：Bracket","path":"2018/07/15/括号匹配/"},{"title":"zuma","text":"题目大意： 给出一串数列v[1…n],一次可以消去其中的一段回文串（例如1 2 3 2 1），然后将这一段数字从v中移除。请问最少消多少次可以消除整个数列。 题解： 设f[l,r]为消去区间v[l,r]的最少需要的次数。 dfs即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 520 using namespace std; int f[N][N],a[N],n; int dfs(int l,int r){ if(f[l][r])return f[l][r]; if(l&gt;r)return 0; f[l][r]=1+dfs(l+1,r); for(int i=l+1;i&lt;=r;i++)if(a[i]==a[l]){ if(i==l+1)f[l][r]=min(f[l][r],1+dfs(i+1,r)); else f[l][r]=min(f[l][r],dfs(l+1,i-1)+dfs(i+1,r)); } return f[l][r]; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;%d&quot;,dfs(1,n)); } 原题链接：zuma","path":"2018/07/15/消除回文串/"},{"title":"矩阵乘法","text":"题目大意： 有一个n×nn\\times nn×n的矩阵，有q个询问，每次询问(x1,y1)(x_1,y_1)(x​1​​,y​1​​)为左上角(x2,y2)(x_2,y_2)(x​2​​,y​2​​)为右下角的矩阵中第k小的数是多少。 题解： 考虑离线，整体二分答案，用树状数组判断是否可行，然后将询问往两边推即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define lowbit(x) (x&amp;-x) using namespace std; struct node{ int x,y,w; }a[2000*2000]; struct arr{ int xa,xb,ya,yb,k,id; }q[620000],rx[620000],lx[620000]; int t[2000][2000],n,m,ans[620000]; int insert(int x,int y,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=n;j+=lowbit(j))t[i][j]+=k; } int query(int x,int y){ int ans=0; for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j))ans+=t[i][j]; return ans; } bool cmp(node x,node y){ return x.w&lt;y.w; } int find(int xb,int yb,int xa,int ya){ return query(xa,ya)-query(xa,yb-1)-query(xb-1,ya)+query(xb-1,yb-1); } int solve(int l,int r,int L,int R){ int mid=(l+r)/2; if(l==r){ for(int i=L;i&lt;=R;i++)ans[q[i].id]=a[l].w; return 0; } int o=0,u=0; for(int i=l;i&lt;=mid;i++)insert(a[i].x,a[i].y,1); for(int i=L;i&lt;=R;i++){ int t=find(q[i].xa,q[i].ya,q[i].xb,q[i].yb); if(t&lt;q[i].k){ q[i].k-=t; rx[++o]=q[i]; } else lx[++u]=q[i]; } for(int i=l;i&lt;=mid;i++)insert(a[i].x,a[i].y,-1); for(int i=L;i&lt;=L+u-1;i++)q[i]=lx[i-L+1]; for(int i=L+u;i&lt;=R;i++)q[i]=rx[i-L-u+1]; solve(l,mid,L,L+u-1); solve(mid+1,r,L+u,R); } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int x,tot=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%d&quot;,&amp;x); a[++tot].x=i; a[tot].y=j; a[tot].w=x; } } sort(a+1,a+1+tot,cmp); for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d%d&quot;,&amp;q[i].xa,&amp;q[i].ya,&amp;q[i].xb,&amp;q[i].yb,&amp;q[i].k),q[i].id=i; solve(1,tot,1,m); for(int i=1;i&lt;=m;i++)printf(&quot;%d\\n&quot;,ans[i]); } 原题链接：矩阵乘法","path":"2018/07/15/矩阵第k大/"},{"title":"聪聪可可","text":"题目大意： 给出一棵树，询问树上有多少路径长度是3的倍数。 题解： 对于每个点维护从这个点到其子树模3为0,1,2的路径数然后随意统计一下答案即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int tot,Next[N],v[N],w[N],h[N],ans,n; int f[N][3],b[3]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int dfs(int x,int fa){ //xx f[x][0]++; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; b[0]=0,b[1]=0,b[2]=0; dfs(v[i],x); b[(0+w[i])%3]=f[v[i]][0]; b[(1+w[i])%3]=f[v[i]][1]; b[(2+w[i])%3]=f[v[i]][2]; ans+=(b[0]*f[x][0])+(b[1]*f[x][2])+(b[2]*f[x][1]); f[x][0]+=b[0]; f[x][1]+=b[1]; f[x][2]+=b[2]; } } int gcd(int x,int y){ if(x%y==0)return y; return gcd(y,x%y); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } dfs(1,0); int l=gcd(ans*2+n,n*n); printf(&quot;%d/%d\\n&quot;,(ans*2+n)/l,(n*n)/l); } 原题链接：聪聪可可","path":"2018/07/15/聪聪可可/"},{"title":"兔子与樱花","text":"题目大意： 很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。兔子们所在森林里的樱花树很特殊。樱花树由n个树枝分叉点组成，编号从0到n-1，这n个分叉点由n-1个树枝连接，我们可以把它看成一个有根树结构，其中0号节点是根节点。这个树的每个节点上都会有一些樱花，其中第i个节点有cic_ic​i​​朵樱花。樱花树的每一个节点都有最大的载重m，对于每一个节点i，它的儿子节点的个数和i节点上樱花个数之和不能超过m，即soni+ci≤mson_i+c_i\\leq mson​i​​+c​i​​≤m，其中sonison_ison​i​​表示i的儿子的个数，如果i为叶子节点，则soni=0son_i=0son​i​​=0。 现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。 现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。 注意根节点不能被删除，被删除的节点不被计入载重。 题解： 对于最终删完之后的树来说，先删上层的点还是先删下层的点的顺序没有影响。而如果一个第i层的点删到i-2层的点上，则意味着第i-1层的点往上删了，那么，也就相当于先把第i层删到第i-1层再往上删到第i-2层。意味着，每个点往父亲删就可以了。对于每个节点往儿子贪心即可。 (场上随手写的一个贪心居然A掉了qwq) #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 4200000 using namespace std; int tot,Next[N],v[N],h[N],a[N],b[N]; int ans,m,n; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ for(int i=h[x];i;i=Next[i]){ a[x]++; dfs(v[i],x); } int tot=0; for(int i=h[x];i;i=Next[i]){ b[++tot]=a[v[i]]; } sort(b+1,b+1+tot); for(int i=1;i&lt;=tot;i++){ if(a[x]+b[i]-1&lt;=m)a[x]+=b[i]-1,ans++; } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++){ int o; scanf(&quot;%d&quot;,&amp;o); for(int j=1;j&lt;=o;j++){ int x; scanf(&quot;%d&quot;,&amp;x); x++; add(i,x); } } dfs(1,0); printf(&quot;%d\\n&quot;,ans); } 原题链接：兔子与樱花","path":"2018/07/15/兔子与樱花/"},{"title":"rank","text":"题目大意： 大M正与其他m只怪兽一起参加一次吃人比赛。这场比赛总共有n轮，在每轮中吃的人越多，排名越靠前（任意一轮中不会出现任意两只怪兽吃人数相等）。最终的排名取决于各轮排名数值之和：排名数值之和越小，最终的排名越靠前。大M找到了你，想知道它在这次比赛中的期望排名。 题解： 设f[i,j]为除大M外经过第i轮后排名总和为j的期望人数,然后利用前缀和快速转移，时间复杂度O(n×m2)O(n\\times m^2)O(n×m​2​​)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200 using namespace std; int a[N],n,m,sum; double ans,f[2][N*N]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),sum+=a[i]; f[0][0]=m-1; int o=0; for(int i=1;i&lt;=n;i++){ o^=1; memset(f[o],0,sizeof(f[o])); double l=0; for(int j=1;j&lt;=sum;j++){ l+=f[o^1][j-1]; if(j&gt;m)l-=f[o^1][j-m-1]; f[o][j]+=(l-(j-a[i]&gt;=0?f[o^1][j-a[i]]:0))/(m-1); } } for(int i=1;i&lt;sum;i++)ans+=f[o][i]; printf(&quot;%.15lf&quot;,ans+1); } 原题链接：rank","path":"2018/07/14/期望排名/"},{"title":"sequence","text":"题目大意： 给定一个数字串，求划分为上升子串的（这里子串的大小为转成数字的大小）方案数。 题解： 考虑fi,jf_{i,j}f​i,j​​为当前划分段从i到k（k&gt;=j）的方案数（从后往前划分）。然后预处理O（1）判断串之间的大小即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 5200 #define P 1000000007 using namespace std; int f[N][N],c[N][N],n; char s[N]; int check(int x,int y){ int l=min(y-x,c[x][y]); return s[x+l]&lt;s[y+l]; } int main(){ scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); for(int i=n;i;i--) for(int j=i+1;j&lt;=n;j++) if(s[i]==s[j])c[i][j]=c[i+1][j+1]+1; for(int i=n;i;i--) if(s[i]!='0'){ f[i][n-i+1]=1; for(int j=1;j&lt;=n-i;j++) if(check(i,i+j))f[i][j]=f[i+j][j]; else f[i][j]=f[i+j][j+1]; for(int j=n-i;j;j--)f[i][j]=(f[i][j]+f[i][j+1])%P; } printf(&quot;%d\\n&quot;,f[1][1]); } 原题链接：sequence","path":"2018/07/14/上升子串/"},{"title":"string","text":"题目大意: 给出一个长度为n的字符串s（由前p个小写字母组成），若给出由前p个小写字母组成的排列ts,并且将其首尾相连至少K次之后得到最终串ss(例如ts=abc,k=3，ts重复k次之后得到abcabcabc)使得原串s是ss的一个子序列，则我们称s是关于ts的“K-repeat”。 现在给出m个操作： 1：将字符串s的第L到R个字符全部替换为ch； 2：给出一个字符串ts，询问s是否为关于ts的“K-repeat”，输出K。 注意：读入所给出的s,ch全部都由前p个小写字母组成。 注意：读入所给出的s,ch全部都由前p个小写字母组成。 题解： 考虑答案为（n-多余次数） 多余次数为ts在s中出现了一段长度为o的，多余次数就是o-1。 那么维护s中相邻字符的点对，减掉这样的点对即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define N 820000 using namespace std; int ls[N],rs[N],v[N][12][12],tag[N]; int n,m,p,l,r,ans; char s[N]; int clear(int k,int x){ tag[k]=x;ls[k]=rs[k]=x; for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) v[k][i][j]=0; } int pushdown(int i){ if(!tag[i])return 0; clear(2*i,tag[i]); clear(2*i+1,tag[i]); tag[i]=0; } int pushup(int x){ for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) v[x][i][j]=v[2*x][i][j]+v[2*x+1][i][j]; if(ls[2*x+1]!=rs[2*x])v[x][rs[2*x]][ls[2*x+1]]++; ls[x]=ls[2*x];rs[x]=rs[2*x+1]; } int build(int i,int l,int r){ if(l==r){ ls[i]=rs[i]=s[l]-'a'+1; return 0; } int mid=(l+r)/2; build(2*i,l,mid); build(2*i+1,mid+1,r); pushup(i); } int change(int i,int l,int r,int ll,int rr,int x){ if(ll&lt;=l&amp;&amp;r&lt;=rr){ clear(i,x); return 0; } int mid=(l+r)/2; pushdown(i); if(ll&lt;=mid)change(2*i,l,mid,ll,rr,x); if(rr&gt;mid)change(2*i+1,mid+1,r,ll,rr,x); pushup(i); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); scanf(&quot;%s&quot;,s+1); build(1,1,n); while(m--){ int x; scanf(&quot;%d&quot;,&amp;x); if(x==1){ char ch; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); scanf(&quot;%c%c&quot;,&amp;ch,&amp;ch); change(1,1,n,l,r,ch-'a'+1); }else{ scanf(&quot;%s&quot;,s+1); ans=n; for(int j=1;j&lt;=p;j++) for(int i=1;i&lt;j;i++) ans-=v[1][s[i]-'a'+1][s[j]-'a'+1]; printf(&quot;%d\\n&quot;,ans); } } } 原题链接：string","path":"2018/07/14/k重复/"},{"title":"Count on a tree","text":"题目大意： 询问树上链第k小的点值，强制在线。 题解： 树上可持久化线段树，时间复杂度O(nlogn)O(n\\log n)O(nlogn)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 1690000 #define M 220000 using namespace std; int n,m; int h[M],v[M],Next[M],rt[M],f[21][M],tot,dep[M]; int a[M],b[M],c[M]; struct seg{ int lx[N],rx[N],siz[N],l[N],r[N]; int insert(int i,int j,int a){ if(lx[i]==0){lx[i]=1,rx[i]=n;} if(lx[i]==rx[i]){ siz[i]=siz[j]+1; return 0; } int mid=(lx[i]+rx[i])/2; if(a&lt;=mid){ r[i]=r[j]; l[i]=++tot; lx[tot]=lx[i]; rx[tot]=mid; insert(l[i],l[j],a); }else{ l[i]=l[j]; r[i]=++tot; lx[tot]=mid+1; rx[tot]=rx[i]; insert(r[i],r[j],a); } siz[i]=siz[l[i]]+siz[r[i]]; } int query(int x,int y,int z,int fa,int k){ if(max(max(lx[x],lx[y]),max(lx[z],lx[fa]))==max(max(rx[x],rx[y]),max(rx[z],rx[fa])))return max(max(lx[x],lx[y]),max(lx[z],lx[fa])); int ls=siz[l[x]]+siz[l[y]]-siz[l[z]]-siz[l[fa]]; if(ls&gt;=k)return query(l[x],l[y],l[z],l[fa],k); else return query(r[x],r[y],r[z],r[fa],k-ls); } }s; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ dep[x]=dep[fa]+1; rt[x]=++tot; f[0][x]=fa; for(int i=1;i&lt;=20;i++)f[i][x]=f[i-1][f[i-1][x]]; s.insert(rt[x],rt[fa],c[x]); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); } } int lca(int x,int y){ if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i&gt;=0;i--)if(dep[f[i][x]]&gt;=dep[y])x=f[i][x]; if(x==y)return x; for(int i=20;i&gt;=0;i--){ if(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y]; } return f[0][x]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++)b[i]=a[i]; sort(b+1,b+1+n); for(int i=1;i&lt;=n;i++)c[i]=lower_bound(b+1,b+1+n,a[i])-b; for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } tot=0; dfs(1,0); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,dep[i]); int lastans=0; for(int i=1;i&lt;=m;i++){ int x,y,k; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); x^=lastans; int z=lca(x,y); int ans=s.query(rt[x],rt[y],rt[z],rt[f[0][z]],k); printf(&quot;%d\\n&quot;,b[ans]); lastans=b[ans]; } }","path":"2018/07/14/树上计数/"},{"title":"病毒","text":"题目大意： 给定一堆01串，指定这些不能出现，问是否能够构造出一个无限长度的字符串满足这些都没有出现过。 题解： 直接建出trie图，判断有没有环（字符串末尾的点都不能经过） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 320000 using namespace std; char s[N]; int ch[N][2]; int tot,tag[N],fail[N],q[N],p[N],l[N],n; int insert(){ int l=strlen(s+1); int x=0; for(int i=1;i&lt;=l;i++){ if(ch[x][s[i]-'0']==0)ch[x][s[i]-'0']=++tot; x=ch[x][s[i]-'0']; } tag[x]=1; } int head,tail; int build(){ head=0,tail=0; int x=0; for(int i=0;i&lt;=1;i++)if(ch[x][i])q[++tail]=ch[x][i]; while(head&lt;tail){ int now=q[++head]; for(int i=0;i&lt;=1;i++){ if(!ch[now][i]){ch[now][i]=ch[fail[now]][i];continue;} q[++tail]=ch[now][i]; int p=fail[now]; while(p&amp;&amp;!ch[p][i])p=fail[p]; fail[ch[now][i]]=ch[p][i]; tag[ch[now][i]]|=tag[fail[ch[now][i]]]; } } } int dfs(int x){ p[x]++; l[x]++; for(int i=0;i&lt;=1;i++){ if(tag[ch[x][i]])continue; if(p[ch[x][i]])return 1; if(l[ch[x][i]])continue; if(dfs(ch[x][i]))return 1; } p[x]--; return 0; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); insert(); } build(); if(dfs(0))printf(&quot;TAK\\n&quot;); else printf(&quot;NIE\\n&quot;); }","path":"2018/07/14/病毒/"},{"title":"game with probability","text":"题目大意： Alice和Bob在玩一个游戏。有n个石子在这里，Alice和Bob轮流投掷硬币，如果正面朝上，则从n个石子中取出一个石子，否则不做任何事。取到最后一颗石子的人胜利。Alice在投掷硬币时有p的概率投掷出他想投的一面，同样，Bob有q的概率投掷出他相投的一面。 现在Alice先手投掷硬币，假设他们都想赢得游戏，问你Alice胜利的概率为多少。 题解： 考虑f[i]表示还剩下i个石子时，Alice先手，Alice必胜的概率 考虑g[i]表示还剩下i个石子时，Bob先手，Alice必胜的概率（Bob好可怜qwq） 假设每次都是的决策都是想取石子 fi=p×gi−1+(1−p)×gif_i=p\\times g_{i-1}+(1-p)\\times g_if​i​​=p×g​i−1​​+(1−p)×g​i​​ $g_i=q\\times f_{i-1}+(1-q)\\times f_i $ 联立一下得： fi=p×gi−1+(1−p)×q×fi−1p+q−p×qf_{i}=\\frac{p\\times g_{i-1}+(1-p)\\times q\\times f_{i-1}}{p+q-p\\times q}f​i​​=​p+q−p×q​​p×g​i−1​​+(1−p)×q×f​i−1​​​​ gi=q×fi−1+(1−q)×p×gi−1p+q−p×qg_{i}=\\frac{q\\times f_{i-1}+(1-q)\\times p\\times g_{i-1}}{p+q-p\\times q}g​i​​=​p+q−p×q​​q×f​i−1​​+(1−q)×p×g​i−1​​​​ 考虑每次是否想取石子，如果fi−1f_{i-1}f​i−1​​比gi−1g_{i-1}g​i−1​​大，说明取完之后Alice先手的胜率高，也就是Alice要在这里先手会比较优，那Alice就不会想取第i个。而跟Alice的更优决策点，应该是一样的，所以Bob也不会想要。反而亦之。最后输出fnf_nf​n​​也就是答案。总体复杂度是O(n)O(n)O(n)的，但是n特别大，但我们可以打表发现这玩意是收敛的（不知道为什么收敛），于是最多求到十万项就可以不管了。就变成了O(min(n,10000))O(min(n,10000))O(min(n,10000))(好像有人只扫了一百次就过了qwq)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int n,t; double f[N],g[N],p,q; int solve(){ scanf(&quot;%d%lf%lf&quot;,&amp;n,&amp;p,&amp;q); n=min(n,110000); g[0]=1; for(int i=1;i&lt;=n;i++){ if(f[i-1]&gt;g[i-1])p=1.0-p,q=1.0-q; f[i]=(p*g[i-1]+(1-p)*q*f[i-1])/(p+q-p*q); g[i]=(q*f[i-1]+(1-q)*p*g[i-1])/(p+q-p*q); if(f[i-1]&gt;g[i-1])p=1.0-p,q=1.0-q; } printf(&quot;%.6lf\\n&quot;,f[n]); } int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--)solve(); }","path":"2018/07/14/概率游戏/"},{"title":"JLOI2015 骗我呢","text":"题目大意： 给出n和m，求满足ai,j&lt;ai−1,j+1a_{i,j}&lt;a_{i-1,j+1}a​i,j​​&lt;a​i−1,j+1​​且ai,j&lt;ai,j+1a_{i,j}&lt;a_{i,j+1}a​i,j​​&lt;a​i,j+1​​且0≤ai,j≤m,1≤i≤n,1≤j≤m0\\leq a_{i,j}\\leq m,1\\leq i\\leq n,1\\leq j\\leq m0≤a​i,j​​≤m,1≤i≤n,1≤j≤m的方案数。 题解： 考虑每一行，ai,j&lt;ai,j+1a_{i,j}&lt;a_{i,j+1}a​i,j​​&lt;a​i,j+1​​，总共m个数，而值只有m+1个，意味着每一行只有一个位置的差会为2，其他都为1。 考虑对于每上面一行，ai,j&lt;ai−1,j+1a_{i,j}&lt;a_{i-1,j+1}a​i,j​​&lt;a​i−1,j+1​​，意味着对于第i行来说，他突变的位置最前能够比第i-1行的突变位置前一格。 得到O(nm)O(nm)O(nm)的方程，设fi,jf_{i,j}f​i,j​​表示第i行的未突变位置小于等于j的方案数。fi,j=fi−1,j+1+fi,j−1f_{i,j}=f_{i-1,j+1}+f_{i,j-1}f​i,j​​=f​i−1,j+1​​+f​i,j−1​​。j的范围为0到m。f0,0=1f_{0,0}=1f​0,0​​=1(因为小于等于相当于求前缀和，所以可以只有一个点有值)。 考虑将对于第i行，将其第二维下标向右移i行，得到方程fi,j=fi−1,j+fi,j−1f_{i,j}=f_{i-1,j}+f_{i,j-1}f​i,j​​=f​i−1,j​​+f​i,j−1​​。而j的范围是从i到i+m。那么原题就转化成了对一个n+1行n+m+1列的网格图(这里说的是格点)，有两条线不能越过（y=x+1,y=x−(m+2)y=x+1,y=x-(m+2)y=x+1,y=x−(m+2)），从（1,1）走到（n+1,n+m+1）的方案数。 答案等于=全集-先越过A线的-先越过B线的。 将多次触碰同一条线视为一次触碰，那么一条线触碰AB的方案要么是ABABABAB……，要么是BABABABA……。对于先触碰A的，我们考虑先删掉以A结尾的方案，加上以BA结尾的方案，减掉以ABA结尾的方案……，直到方案数为０，就退出（每次至少向前移动一次，最多移动Ｏ（ｎ）次）。那么就可以减掉所有第一次触碰禁忌线A的方案。同理可删除先触碰B的。 对于末尾为A的方案数计算，将终点对A线对称翻转，然后直接计算从(1,1)到对称点的方案（因为将路径沿A翻转，必定过A然后到终点。）而计算BA为末尾，就将点再沿B对称过去，计算(1,1)到对称点的方案。以此类推。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 13000000 #define P 1000000007 using namespace std; long long fac[N],ifac[N]; int n,m; long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int pre(){ fac[0]=1; for(int i=1;i&lt;=12000000;i++)fac[i]=fac[i-1]*i%P; ifac[12000000]=power(fac[12000000],P-2); for(int i=11999999;i&gt;=0;i--)ifac[i]=ifac[i+1]*(i+1)%P; } long long C(long long n,long long m){ return fac[n]*ifac[m]%P*ifac[n-m]%P; } long long calc(int x,int y){ if(x&lt;0||y&lt;0)return 0; return C(x+y,x); } int flipA(int &amp;x,int &amp;y){ swap(x,y); x--;y++; } int flipB(int &amp;x,int &amp;y){ swap(x,y); x+=m+2; y-=m+2; } int main(){ pre(); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); long long ans=calc(n+m+1,n); int x=n+m+1,y=n; while(x&gt;=0&amp;&amp;y&gt;=0){ flipA(x,y); ans-=calc(x,y); flipB(x,y); ans+=calc(x,y); ans%=P; } x=n+m+1,y=n; while(x&gt;=0&amp;&amp;y&gt;=0){ flipB(x,y); ans-=calc(x,y); flipA(x,y); ans+=calc(x,y); ans%=P; } ans+=P; ans%=P; printf(&quot;%lld&quot;,ans); }","path":"2018/07/08/JLOI2015-骗我呢/"},{"title":"JLOI2015 装备购买","text":"题目大意： 给n个装备，每个装备有m个属性，求花费最小的基底。 题解： 排序，贪心，然后用线性基维护即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; #define eps 1e-8 const int N=505; int n,m; long double lb[N][N]; struct node{ long double a[N]; int w; }s[N]; int tot,ans; bool cmp(node x,node y){return x.w&lt;y.w;} int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=m;j++)scanf(&quot;%llf&quot;,&amp;s[i].a[j]); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i].w); sort(s+1,s+1+n,cmp); for(int x=1;x&lt;=n;x++) for(int i=1;i&lt;=m;i++) if(fabs(s[x].a[i])&gt;=eps){ if(fabs(lb[i][i])&lt;eps){ for(int j=i;j&lt;=m;j++)lb[i][j]=s[x].a[j]; tot++; ans+=s[x].w; break; } for(int j=m;j&gt;=i;j--)s[x].a[j]-=lb[i][j]*(s[x].a[i]/lb[i][i]); } printf(&quot;%d %d\\n&quot;,tot,ans); }","path":"2018/07/08/JLOI2015-装备购买/"},{"title":"JLOI2015 城池攻占","text":"题目描述： 小铭铭最近获得了一副新的桌游，游戏中需要用m个骑士攻占n个城池。 这n个城池用1到n的整数表示。除1号城池外，城池i会受到另一座城池fif_if​i​​的管辖，其中fi&lt;if_i &lt;if​i​​&lt;i。也就是说，所有城池构成了一棵有根树。这m个骑士用1到m的整数表示，其中第i个骑士的初始战斗力为sis_is​i​​，第一个攻击的城池为cic_ic​i​​。 每个城池有一个防御值hih_ih​i​​，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领1号城池，或牺牲为止。 除1号城池外，每个城池i会给出两个战斗力变化参数aia_ia​i​​, viv_iv​i​​。若ai=0a_i=0a​i​​=0，攻占城池i以后骑士战斗力会增加viv_iv​i​​；若ai=1a_i =1a​i​​=1，攻占城池i以后，战斗力会乘以viv_iv​i​​。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。 现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。 题解： 考虑对于一个点来说，初始值越大，最后能到达的高度也就越高。那么直接倍增维护跳2^i所需的初始值，并将函数复合即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 320000 using namespace std; long long fa[21][N],f[21][N],g[21][N],l[21][N]; long long p[N],a[N],v[N]; long long ans[N],bns[N]; int n,m; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;p[i]); for(int i=2;i&lt;=n;i++)scanf(&quot;%lld%lld%lld&quot;,&amp;fa[0][i],&amp;a[i],&amp;v[i]); for(int i=1;i&lt;=n;i++){ f[0][i]=1;g[0][i]=0; if(a[i]==0)g[0][i]=v[i]; else f[0][i]=v[i]; l[0][i]=p[i]; for(int j=1;j&lt;=20;j++){ fa[j][i]=fa[j-1][fa[j-1][i]]; if(fa[j][i]==0)break; f[j][i]=f[j-1][fa[j-1][i]]*f[j-1][i]; g[j][i]=g[j-1][fa[j-1][i]]+f[j-1][fa[j-1][i]]*g[j-1][i]; l[j][i]=max(l[j-1][i],(l[j-1][fa[j-1][i]]-g[j-1][i])/f[j-1][i]+((l[j-1][fa[j-1][i]]-g[j-1][i])%f[j-1][i]!=0)); } } for(int i=1;i&lt;=m;i++){ long long x,y; scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); int k=i; for(int i=20;i&gt;=0;i--){ if(fa[i][y]==0)continue; if(x&gt;=l[i][y]){ bns[k]+=(1&lt;&lt;i); x=x*f[i][y]+g[i][y]; y=fa[i][y]; } } if(x&gt;=p[y])bns[i]++; else ans[y]++; } for(int i=1;i&lt;=n;i++)printf(&quot;%d\\n&quot;,ans[i]); for(int i=1;i&lt;=m;i++)printf(&quot;%d\\n&quot;,bns[i]); }","path":"2018/07/08/JLOI2015-城池攻占/"},{"title":"JLOI2015 有意义的字符串","text":"题目大意： 求[(b+d2)n][(\\frac{b+\\sqrt{d}}{2})^n][(​2​​b+√​d​​​​​)​n​​] mod 752844341257957693775284434125795769377528443412579576937。 题解： 将式子转化成([(b+d2)n]+[(b−d2)n])−[(b−d2)n]([(\\frac{b+\\sqrt{d}}{2})^n]+[(\\frac{b-\\sqrt{d}}{2})^n])-[(\\frac{b-\\sqrt{d}}{2})^n]([(​2​​b+√​d​​​​​)​n​​]+[(​2​​b−√​d​​​​​)​n​​])−[(​2​​b−√​d​​​​​)​n​​] 将左边看成特征方程的两个解，还原特征方程。 x2−bx+b2−d4=0x^2-bx+\\frac{b^2-d}{4}=0x​2​​−bx+​4​​b​2​​−d​​=0 将式子左边括号中转成一个数列a，得an=an−1b+an−2d−b24a_n=a_{n-1}b+a_{n-2}\\frac{d-b^2}{4}a​n​​=a​n−1​​b+a​n−2​​​4​​d−b​2​​​​ 这个数列可通过矩阵快速幂求得，而减号后的只会为0或者1（按照数据范围讨论），特判即可。 复杂度O(log2n)O(\\log^2n)O(log​2​​n)：因为这个模数很恶心，所以要再花一个log时间来快速乘法，使得不会爆longlong。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 7528443412579576937LL using namespace std; struct matrix{ long long a[3][3]; int clear(){memset(a,0,sizeof(a));} }E; long long add(long long x,long long y){ long long ans=-P+x+y; if(ans&lt;0)ans+=P; return ans; } long long mul(long long x,long long y){ long long ans=0; while(y){ if(y&amp;1)ans=add(ans,x); x=add(x,x); y&gt;&gt;=1; } return ans; } matrix operator * (matrix a,matrix b){ matrix ans; ans.clear(); for(int i=1;i&lt;=2;i++){ for(int j=1;j&lt;=2;j++){ for(int k=1;k&lt;=2;k++){ ans.a[i][j]=add(mul(a.a[i][k],b.a[k][j]),ans.a[i][j]); } } } return ans; } matrix power(matrix x,long long k){ matrix ans; ans.clear(); ans=E; while(k){ if(k&amp;1)ans=ans*x; x=x*x; k&gt;&gt;=1; } return ans; } int main(){ E.a[1][1]=1; E.a[2][2]=1; long long b,d,n; scanf(&quot;%lld%lld%lld&quot;,&amp;b,&amp;d,&amp;n); matrix o; o.clear(); o.a[1][1]=2; o.a[1][2]=b; matrix p; p.clear(); p.a[2][1]=1; p.a[2][2]=b; p.a[1][2]=(d-b*b)/4; o=o*power(p,n); printf(&quot;%lld&quot;,o.a[1][1]-(b*b!=d&amp;&amp;n%2==0)); }","path":"2018/07/05/JLOI2015-有意义的字符串/"},{"title":"NOI2014 购票","text":"题目大意： 有一棵树，对于每个点v有四个参数,svs_vs​v​​,pvp_vp​v​​,qvq_vq​v​​,lvl_vl​v​​。 svs_vs​v​​表示当前点到父亲节点的距离。如果d为每次跳跃的距离，那么每次跳跃的费用为dpv+qvdp_v+q_vdp​v​​+q​v​​。现在所有点都要去到1号点，并且他们每次往上跳不能超过距离lvl_vl​v​​。对于每个点求最小花费。 n≤2∗105n\\leq2*10^5n≤2∗10​5​​,其余所有运算不超过longlong。 题解： 链上做法：斜率优化 设did_id​i​​为1号点到i号点的距离 fi=min(fj+(di−dj)pi+qi)f_i=min(f_j+(d_i-d_j)p_i+q_i)f​i​​=min(f​j​​+(d​i​​−d​j​​)p​i​​+q​i​​) 设选k由于j且dk&gt;djd_k&gt;d_jd​k​​&gt;d​j​​： fk+(di−dk)pi+qi&lt;fj+(di−dj)pi+qif_k+(d_i-d_k)p_i+q_i&lt;f_j+(d_i-d_j)p_i+q_if​k​​+(d​i​​−d​k​​)p​i​​+q​i​​&lt;f​j​​+(d​i​​−d​j​​)p​i​​+q​i​​ 整理得： fk−fjdk−dj&lt;pi\\frac{f_k-f_j}{d_k-d_j}&lt;p_i​d​k​​−d​j​​​​f​k​​−f​j​​​​&lt;p​i​​ 树链剖分+凸包合并O(nlog3n)O(n\\log^3 n)O(nlog​3​​n)： 对于一条链来说，直接斜率优化即可，那么对于树上，我们可以按照dfs的顺序，一次加入点，并将树树剖，依次求出f值，在插入线段树的时候，只有左右儿子都是满时才合并，因为没加入的都不会被查询，所以可在(nlog3n)(n\\log^3n)(nlog​3​​n)的时间里求出答案（树剖一条链会有log段，限制lil_il​i​​在线段树上取区间总共有log个，每个区间二分得到答案又一个log）（因为树剖常数小所以能过qwq）（然而懒惰的我写了下面的方法。） CDQ+树分治+凸包合并O(nlog2n)O(n\\log^2n)O(nlog​2​​n)： 对于每次分治，把重心堵住，不停地堵住，然后利用当前节点到重心的链去更新重心答案，再递归计算。（看代码应该极好理解） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 420000 #define slope(x,y) ((f[y]-f[x]+0.0)/(d[y]-d[x])) #define cal(i,j) (0LL+f[j]+(d[i]-d[j])*p[i]+q[i]) using namespace std; long long n,fa[N],tot,h[N],v[N],Next[N],siz[N],g[N],cnt,Q[N],o[N]; long long p[N],q[N],L[N],d[N],w[N],f[N]; struct node{long long w,id;}a[N]; bool cmp(node x,node y){return x.w&gt;y.w;} int add(int x,int y,long long z){ Next[++tot]=h[x]; h[x]=tot; v[tot]=y; w[tot]=z; } int dfs(int x){ siz[x]=1; for(int i=h[x];i;i=Next[i]){ d[v[i]]=d[x]+w[i]; dfs(v[i]); siz[x]+=siz[v[i]]; } } int get(int x,int S,int &amp;rt){ g[x]=0; siz[x]=1; for(int i=h[x];i;i=Next[i]){ if(o[v[i]])continue; get(v[i],S,rt); siz[x]+=siz[v[i]]; g[x]=max(g[x],siz[v[i]]); } g[x]=max(g[x],S-siz[x]); if(g[x]&lt;g[rt]&amp;&amp;siz[x]&gt;1)rt=x; } int dfs2(int x){ a[++cnt].id=x; a[cnt].w=d[x]-L[x]; for(int i=h[x];i;i=Next[i])if(!o[v[i]])dfs2(v[i]); } int solve(int x,int S){ if(x==2){ x++; x--; } if(S==1)return 0; int rt=0,now; get(x,S,rt); for(int i=h[rt];i;i=Next[i])o[v[i]]=1; solve(x,S-siz[rt]+1); cnt=0; for(int i=h[rt];i;i=Next[i])dfs2(v[i]); sort(a+1,a+cnt+1,cmp); now=rt; int top,l,r,mid,pos; top=0; for(int i=1;i&lt;=cnt;i++){ while(now!=fa[x]&amp;&amp;d[a[i].id]-L[a[i].id]&lt;=d[now]){ while(top&gt;1&amp;&amp;slope(Q[top],now)&gt;=slope(Q[top-1],Q[top]))top--; Q[++top]=now;now=fa[now]; } if(top&gt;0){ l=1;r=top;pos=1; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(mid==top){pos=top;break;} if(slope(Q[mid],Q[mid+1])&gt;=p[a[i].id])l=mid+1,pos=mid+1; else r=mid-1; } f[a[i].id]=min(f[a[i].id],cal(a[i].id,Q[pos])); } } for(int i=h[rt];i;i=Next[i])solve(v[i],siz[v[i]]); } int main(){ long long x; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;x); for(int i=2;i&lt;=n;i++){ scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;x,&amp;p[i],&amp;q[i],&amp;L[i]); add(fa[i],i,x); } dfs(1); g[0]=n+1; for(int i=2;i&lt;=n;i++)f[i]=1LL&lt;&lt;60; solve(1,siz[1]); for(int i=2;i&lt;=n;i++)printf(&quot;%lld\\n&quot;,f[i]); }","path":"2018/07/05/NOI2014-购票/"},{"title":"NOI2014 随机数生成器","text":"题目大意： 给出一个随机生成的矩阵（数字为1到n*m），求字典序最小的排序后的从(1,1)(1,1)(1,1)到(n,m)(n,m)(n,m)的数字序列。 题解： 按照题意模拟出来之后从小到大贪心，每次加入点之后把不可能的情况排除，直接暴力排除（遇到被排除的就退），因为每个点最多只会被排除一次，所以排除的复杂度是O(n∗m)O(n*m)O(n∗m)的，模拟出矩阵也是O(n∗m)O(n*m)O(n∗m)的，总复杂度为O(n∗m)O(n*m)O(n∗m)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define swap(x,y) t=x;x=y;y=t; using namespace std; int x0,a,b,c,d,n,m,q,tot; int f[26000000],p[26000000],l[10200],r[10200]; static int t; int main(){ scanf(&quot;%d%d%d%d%d&quot;,&amp;x0,&amp;a,&amp;b,&amp;c,&amp;d); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n*m;i++)f[i]=i; for(int i=1;i&lt;=n*m;i++){ x0=(1LL*a*x0*x0+1LL*b*x0+c)%d; swap(f[i],f[x0%i+1]); } static int x,y; for(static int i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); swap(f[x],f[y]); } for(static int i=1;i&lt;=n*m;i++)p[f[i]]=i; for(static int i=1;i&lt;=n*m;i++){ bool ooo=true; int y=(p[i]-1)%m+1; int x=(p[i]-y)/m+1; if(p[i]==0)continue; for(int i=x-1;i&gt;=1;i--){ for(int j=y+1;j&lt;=m;j++){ int ooo=((i-1)*m+j); if(p[f[ooo]]==0)break; p[f[ooo]]=0; } } for(int i=x+1;i&lt;=n;i++){ for(int j=y-1;j&gt;=1;j--){ int ooo=((i-1)*m+j); if(p[f[ooo]]==0)break; p[f[ooo]]=0; } } if(ooo==false)continue; l[++tot]=x; r[tot]=y; printf(&quot;%d &quot;,i); if(tot==n+m-1)return 0; } }","path":"2018/07/02/NOI2014-随机数生成器/"},{"title":"NOI2014 魔法森林","text":"题目大意： 一个无向图，每条边两个值a和b，求1到n路径上的min(max(ai)+max(bj))min(max(a_i)+max(b_j))min(max(a​i​​)+max(b​j​​))。 题解： 按照a为第一关键字，b为第二关键字排序，按顺序加边，再松弛，因为每条边松弛一次，所以跟整张图的SPFA是一个复杂度。相当于对于每个a的可能值都做一次b的最短路，约等于优化暴力（spaly维护最小生成树的做法我不会啊qwq） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 12000000 using namespace std; struct node{ int x,y,a,b; }a[N]; int tot,Next[N],v[N],w[N],h[N],d[N]; int q[N],p[N],n,m; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } bool cmp(node x,node y){ if(x.a==y.a)return x.b&lt;y.b; return x.a&lt;y.a; } int spfa(int x){ q[1]=x; if(x==1){ x++; x--; } int head=0,tail=1; p[x]=1; while(head&lt;tail){ int now=q[++head]; if(d[now]==0)continue; for(int i=h[now];i;i=Next[i]){ if(max(d[now],w[i])&lt;d[v[i]]||d[v[i]]==0){ d[v[i]]=max(d[now],w[i]); if(p[v[i]]==0){ p[v[i]]=1; q[++tail]=v[i]; } } } p[now]=0; } p[x]=0; } int main(){ d[1]=1; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].a,&amp;a[i].b); sort(a+1,a+1+m,cmp); int ans=1000000000,bns=1000000000; for(int i=1;i&lt;=m;i++){ add(a[i].x,a[i].y,a[i].b); add(a[i].y,a[i].x,a[i].b); spfa(a[i].x); spfa(a[i].y); if(d[n]==0)continue; bns=a[i].a+d[n]; if(bns&lt;ans)ans=bns; } spfa(1); if(ans==1000000000)ans=-1; printf(&quot;%d&quot;,ans); }","path":"2018/07/02/NOI2014-魔法森林/"},{"title":"NOI2014 动物园","text":"题目大意： 对于S的每个前缀T，对于T求出有多少个长度小于|T|的前缀和后缀相同，讲每个前缀T的答案加一乘起来膜100000000710000000071000000007。 题解： 直接求Next数组然后倍增就好了。（倍增前后坐标相反能快差不多一倍，不然卡不过去qwq） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200000 #define P 1000000007 using namespace std; char s[N]; long long f[21][N],ans; int Next[N],q[N],g[N]; int cal(int x){ if(f[0][x]==0)return 0; int o=x; for(int i=20;i&gt;=0;i--) if(f[i][o]&gt;x/2)o=f[i][o]; return f[0][o]; } int get(){ memset(f,0,sizeof(f)); memset(q,0,sizeof(q)); memset(g,0,sizeof(g)); memset(Next,0,sizeof(Next)); int l=strlen(s+1); q[1]=1; for(int i=2;i&lt;=l;i++){ int j=Next[i-1]; while(j&amp;&amp;s[j+1]!=s[i])j=Next[j]; Next[i]=j+(s[j+1]==s[i]); q[i]=q[Next[i]]+1; f[0][i]=Next[i]; for(int j=1;j&lt;=20;j++){ f[j][i]=f[j-1][f[j-1][i]]; if(f[j][i]==0)break; } } ans=1; for(int i=1;i&lt;=l;i++)g[i]=q[cal(i)]; for(int i=1;i&lt;=l;i++)(ans*=1LL*g[i]+1)%=P; printf(&quot;%lld\\n&quot;,ans); } int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); get(); } }","path":"2018/07/02/NOI2014-动物园/"},{"title":"NOI2014 起床困难综合征","text":"题目大意： 给定一系列位运算操作，在1到m里选一个数，使这个数在经历一系列操作后值最大。 题解： 对于每一位分别求出输入时是0和1为多少，从高位往低位贪心选择较大值，如果在相同满足要求的结果下选择输入较小的。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; long long n,m,d,ans,l; char s[100]; int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); long long x=0,y=(1LL&lt;&lt;32)-1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); scanf(&quot;%lld&quot;,&amp;d); if(s[1]=='O')x=x|d,y=y|d; if(s[1]=='A')x=x&amp;d,y=y&amp;d; if(s[1]=='X')x=x^d,y=y^d; } for(int i=32;i&gt;=0;i--){ if(x&amp;(1LL&lt;&lt;(i))){ ans+=1LL&lt;&lt;i; }else{ if(y&amp;(1LL&lt;&lt;i)){ if(l+(1LL&lt;&lt;i)&lt;=m){ ans+=1LL&lt;&lt;i; l+=1LL&lt;&lt;i; } } } } printf(&quot;%lld&quot;,ans); }","path":"2018/07/02/NOI2014-起床困难综合征/"},{"title":"NOI2007 生成树计数","text":"题目大意： 有一条链，链上长度不超过k的点之间都会进行连边，求生成树个数。 题解： 60%做法：O(n3)O(n^3)O(n​3​​),n≤100n \\leq 100n≤100 那么直接连边按照，用矩阵树定理高斯消元解行列式即可。 因为n≤100n\\leq100n≤100那么直接连边按照，用矩阵树定理n3n^3n​3​​高斯消元解行列式即可。 100%做法：O(l3log(n))O(l^3log(n))O(l​3​​log(n)),n≤1015n\\leq 10^{15}n≤10​15​​,l为所有联通形式种类，当k=5时l=52。 考虑到对于第i-k号点，如果最后会成为生成树，他必定与i-k+1到i号点中至少一个是一个联通快的。因此，我们维护fi,jf_{i,j}f​i,j​​表示，在当前第i个点，前j个点的联通块是怎么样的，每次转移则是用第i号点与前面的连边情况进行转移，维护判断i-k号点在转移后是否与i-k+1到i号点中的部分点联通。搜索我们可以得到转移矩阵。 初始条件：因为在前k个点中，所有点之间都是两两相连的，n个点的完全图的最小生成树是nn−2n^{n-2}n​n−2​​，这个可用purfer序列简易证明。 关于最小表示法：既联通情况2,2,3,1与联通情况1,1,2,3是相同的，所有本质相同的情况我们用它的最小表示来识别它。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define N 120 #define P 65521 using namespace std; int cnt,k,tot,l; int a[10],b[10],q[60]; long long n; map&lt;int,int&gt;p; struct matrix{ long long a[N][N]; int clear(){memset(a,0,sizeof(a));} int E(){for(int i=1;i&lt;=cnt;i++)a[i][i]=1;} }g,f; matrix operator *(matrix a,matrix b){ matrix ans; ans.clear(); for(int i=1;i&lt;=cnt;i++){ for(int j=1;j&lt;=cnt;j++){ for(int k=1;k&lt;=cnt;k++){ (ans.a[i][j]+=a.a[i][k]*b.a[k][j])%=P; } } } return ans; } matrix power(matrix x,long long k){ matrix ans; ans.clear(); ans.E(); while(k){ if(k&amp;1)ans=ans*x; x=x*x; k&gt;&gt;=1; } return ans; } int get(int x){ memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); int tot=0; for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3); for(int i=1;i&lt;=k;i++){ if(b[a[i]])a[i]=b[a[i]]; else b[a[i]]=++tot,a[i]=tot; } int y=0; for(int i=1;i&lt;=k;i++)y=y&lt;&lt;3,y+=a[i]; return y; } int powerr(int x,int k){ int ans=1; if(k&lt;=0)return ans; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int gett(int x){ int ans=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3),b[a[i]]++; for(int i=1;i&lt;=k;i++)ans*=powerr(b[i],b[i]-2); return ans; } int dfs(int x,int o){ if(x==l){ int y=get(o); if(p[y]==0){ p[y]=++cnt; q[cnt]=y; f.a[1][cnt]=gett(y); } return 0; } for(int i=1;i&lt;=k;i++){ dfs(x+1,(o&lt;&lt;3)+i); } } int check(int x,int y){ int o=0; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3); for(int i=2;i&lt;=k;i++){ if(a[i]==a[1])break; if(y&amp;1)continue; if(i==k)return 0; } for(int i=0;i&lt;k;i++){ if((1&lt;&lt;i)&amp;y){ if(o==0)o=a[i+1]; if(b[a[i+1]]&gt;0)return 0; b[a[i+1]]=o; } } for(int i=1;i&lt;=k;i++)if(b[a[i]]&gt;0)a[i]=o; int l=0; for(int i=2;i&lt;=k;i++)l=(l&lt;&lt;3)+a[i]; l&lt;&lt;=3; if(y!=0)l+=o; else l+=k+1; int ans=get(l); return p[ans]; } int cal(int x){ for(int i=1;i&lt;=cnt;i++){ int l=check(q[i],x); if(l&gt;0){ g.a[i][l]++; } } } int main(){ scanf(&quot;%d%lld&quot;,&amp;k,&amp;n); if(k&gt;n){ printf(&quot;%d&quot;,powerr(n,n-2)); return 0; } l=k; dfs(0,0); for(int i=0;i&lt;(1&lt;&lt;k);i++)cal(i); f=f*power(g,n-k); printf(&quot;%d\\n&quot;,f.a[1][1]); }","path":"2018/06/30/NOI2007-生成树计数/"},{"title":"NOI2007 项链工厂","text":"题目大意： 维护一个环，和一个指针，有以下几种操作（该指针的下标为1，其余为位置的下标顺时针递增）: 1:将指针逆时针移动k位 2:将环以指针做对称轴翻转 3:交换l位置和r位置上的颜色 4:将l到r染成c颜色 5:查询当前项链有多少段颜色（首尾相同算一段） 6: 查询l到r有多少段颜色 题解： 线段树 对于翻转操作，我们修改对应下标，然后更新即可，需要完成的模块有区间更新（lazy标记），区间查询，单点更新，单点查询。 （由于代码是在拍宣传片时候写的，思维极度混乱，由于实现问题甚至需要开八倍空间，这份代码极度丑陋qwq）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 2200000 using namespace std; int a[N],n,c,ooo; struct node{ int lx[N],rx[N],tag[N],t[N],ll,rr,ans; int pushdown(int i){ if(tag[i]){ lx[i]=tag[i]; rx[i]=tag[i]; t[i]=1; tag[i*2]=tag[i]; tag[i*2+1]=tag[i]; tag[i]=0; return 0; } } int merge(int i,int l,int r){ if(tag[l])pushdown(l); if(tag[r])pushdown(r); t[i]=t[l]+t[r]-(rx[l]==lx[r]); lx[i]=lx[l]; rx[i]=rx[r]; } int build(int i,int l,int r){ if(l==r){ lx[i]=a[l]; rx[i]=a[l]; t[i]=1; return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); merge(i,i*2,i*2+1); } int insert(int i,int l,int r,int x,int y,int c){ pushdown(i); if(x&lt;=l&amp;&amp;r&lt;=y){ tag[i]=c; pushdown(i); merge(i,i*2,i*2+1); return 0; } int mid=(l+r)/2; if(mid&gt;=x)insert(i*2,l,mid,x,y,c); if(mid&lt;y)insert(i*2+1,mid+1,r,x,y,c); merge(i,i*2,i*2+1); } int add(int i){ if(ll==0&amp;&amp;rr==0){ ll=lx[i],rr=rx[i]; ans=t[i]; return 0; } ans=t[i]+ans-(rr==lx[i]); rr=rx[i]; return 0; } int query(int i,int l,int r,int x,int y){ pushdown(i); if(x&lt;=l&amp;&amp;y&gt;=r){ add(i);return ans; } int mid=(l+r)/2; if(x&lt;=mid)query(i*2,l,mid,x,y); if(y&gt;mid)query(i*2+1,mid+1,r,x,y); merge(i,i*2,i*2+1); return ans; } int clear(){ ll=0,rr=0; ans=0; return 0; } int insert(int i,int l,int r,int x,int a){ pushdown(i); if(l==r){ t[i]=1; lx[i]=a; rx[i]=a; return 0; } int mid=(l+r)/2; if(x&lt;=mid)insert(i*2,l,mid,x,a); else insert(i*2+1,mid+1,r,x,a); merge(i,i*2,i*2+1); } int query_color(int i,int l,int r,int x){ pushdown(i); if(l==r)return lx[i]; int mid=(l+r)/2; if(x&lt;=mid)return query_color(i*2,l,mid,x); else return query_color(i*2+1,mid+1,r,x); merge(i,i*2,i*2+1); } }s; int q; char ss[10]; int get(int &amp;x){ x%=n;x+=n;x%=n; if(x==0)x=n; } int tot; int main(){ int p=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;c); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); s.build(1,1,n); scanf(&quot;%d&quot;,&amp;q); int o=1; for(int i=1;i&lt;=q;i++){ scanf(&quot;%s&quot;,ss+1); if(ss[1]=='R'){ int k; scanf(&quot;%d&quot;,&amp;k); if(p==0)o-=k; else o+=k; get(o); } if(ss[1]=='F'){p^=1;} if(ss[1]=='S'){ int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; } get(l),get(r); int lx=s.query_color(1,1,n,l),rx=s.query_color(1,1,n,r); s.insert(1,1,n,r,lx); s.insert(1,1,n,l,rx); } if(ss[1]=='P'){ int l,r,x; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; swap(l,r); } get(l),get(r); if(l&lt;=r)s.insert(1,1,n,l,r,x); else s.insert(1,1,n,1,r,x),s.insert(1,1,n,l,n,x); } if(ss[1]=='C'){ tot++; // if(tot==11){ // printf(&quot;\\n&quot;); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,s.query_color(1,1,n,i)); // printf(&quot;\\n&quot;); // } int l=1,r=n,ooo=1; if(ss[2]=='S'){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; swap(l,r); } get(l);get(r); } int ans=0; s.clear(); if(l&lt;=r)ans=s.query(1,1,n,l,r)-(r-l+1==n?(s.query_color(1,1,n,1)==s.query_color(1,1,n,n)):0); else{ ans=s.query(1,1,n,1,r);s.clear(); ans+=s.query(1,1,n,l,n)-(s.query_color(1,1,n,1)==s.query_color(1,1,n,n)); } printf(&quot;%d\\n&quot;,max(ans,1)); } } }","path":"2018/06/28/NOI2007-项链工厂/"},{"title":"NOI2007 货币兑换","text":"题目大意： 股市有n天，有A和B两只股票，给出aia_ia​i​​，bib_ib​i​​表示A劵和B劵的价值，rir_ir​i​​表示每天提供的A劵与B劵的比例（必须按照这个比例来买）。 给出开局的金额S，求n天后最多能得到的钱。 题解： 易证每天必须全部卖出或者全部买入 60%做法，O(n2)dpO(n^2)dpO(n​2​​)dp： fi=max(fi−1,Aj∗ai+Bj∗bi)f_i=\\max(f_{i-1},A_j*a_i+B_j*b_i)f​i​​=max(f​i−1​​,A​j​​∗a​i​​+B​j​​∗b​i​​) 100%做法，O(nlog2n)O(nlog^2n)O(nlog​2​​n)斜率优化+cdq分治: 若k优于j且AkA_kA​k​​&gt;AjA_jA​j​​，则： Aj∗ai+Bj∗bi&lt;Ak∗ai+Bk∗biA_j*a_i+B_j*b_i&lt;A_k*a_i+B_k*b_iA​j​​∗a​i​​+B​j​​∗b​i​​&lt;A​k​​∗a​i​​+B​k​​∗b​i​​ bi∗(Bj−Bk)&lt;ai∗(Ak−Aj)b_i*(B_j-B_k)&lt;a_i*(A_k-A_j)b​i​​∗(B​j​​−B​k​​)&lt;a​i​​∗(A​k​​−A​j​​) −Ak−AjBk−Bj&lt;aibi-\\frac{A_k-A_j}{B_k-B_j}&lt;\\frac{a_i}{b_i}−​B​k​​−B​j​​​​A​k​​−A​j​​​​&lt;​b​i​​​​a​i​​​​ Ak−AjBk−Bj&gt;−aibi\\frac{A_k-A_j}{B_k-B_j}&gt;-\\frac{a_i}{b_i}​B​k​​−B​j​​​​A​k​​−A​j​​​​&gt;−​b​i​​​​a​i​​​​ 考虑将BiB_iB​i​​作为横坐标AiA_iA​i​​作为纵坐标，对于每个i来说，取最优答案即在上凸包做斜率为−aibi-\\frac{a_i}{b_i}−​b​i​​​​a​i​​​​切线处取点。 CDQ分治：solve(l,r) 先按斜率−aibi-\\frac{a_i}{b_i}−​b​i​​​​a​i​​​​排序。在solve(l,r)把时间小于等于mid的放到数组前半段，大于mid的放到数组后半段，solve(l,mid)，并将其暴力构建凸包，对mid+1到r的答案进行更新（这时满足斜率单调的条件，而最先开始的按照斜率排序保证了后半段的查询中斜率式单调递增的）。然后solve(mid+1,r)，最后将l到r中的点按照横纵坐标排序（为了返回之后能构建凸包）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define eps 1e-9 #define N 1200000 using namespace std; struct node{ double a,b,k,x,y,r; int id; }a[N],t[N]; int s[N]; double f[N]; int n; bool cmp(node x,node y){ return x.k&gt;y.k; } bool cmp1(node x,node y){ if(fabs(x.x-y.x)&lt;eps)return x.y&lt;y.y; return x.x&lt;y.x; } bool slope(node x,node y,node z){ return (z.x-x.x)*(y.y-x.y)-eps&lt;(y.x-x.x)*(z.y-x.y); } double slope(node x,node y){ if(fabs(x.x-y.x)&lt;eps)return 1e10; return (y.y-x.y)/(y.x-x.x); } int solve(int l,int r){ if(l==r){ f[l]=max(f[l],f[l-1]); a[l].y=f[l]/(a[l].a*a[l].r+a[l].b); a[l].x=a[l].y*a[l].r; return 0; } int mid=(l+r)/2; int l1=l-1,l2=mid; for(int i=l;i&lt;=r;i++)if(a[i].id&lt;=mid)t[++l1]=a[i];else t[++l2]=a[i]; for(int i=l;i&lt;=r;i++)a[i]=t[i]; solve(l,mid); int top=0; for(int i=l;i&lt;=mid;i++){ while(top&gt;1&amp;&amp;slope(a[s[top-1]],a[s[top]],a[i]))top--; s[++top]=i; } int j=1; for(int i=mid+1;i&lt;=r;i++){ while(j&lt;top&amp;&amp;slope(a[s[j]],a[s[j+1]])+eps&gt;a[i].k)j++; int now=a[i].id,o=s[j]; f[now]=max(f[now],a[i].a*a[o].x+a[i].b*a[o].y); } solve(mid+1,r); l1=l,l2=mid+1; for(int i=l;i&lt;=r;i++)if((l2&gt;r)||(l1&lt;=mid&amp;&amp;cmp1(a[l1],a[l2])))t[i]=a[l1++];else t[i]=a[l2++]; for(int i=l;i&lt;=r;i++)a[i]=t[i]; } int main(){ scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].a,&amp;a[i].b,&amp;a[i].r); a[i].k=-a[i].a/a[i].b; a[i].id=i; } sort(a+1,a+1+n,cmp); solve(1,n); printf(&quot;%.5lf\\n&quot;,f[n]); }","path":"2018/06/28/NOI2007-货币兑换/"},{"title":"NOI2007 社交网络","text":"题目大意： 一个无向连通图，Cs,tC_{s,t}C​s,t​​表示从s到t的最短路条数，Cs,t(v)C_{s,t}(v)C​s,t​​(v)表示经过v从s到t的最短路条数。 对于每个点v，求出l(v)=∑s≠v,t≠vCs,t(v)Cs,tl(v)=\\sum \\limits_{s\\neq v,t \\neq v}\\frac{C_{s,t}(v)}{C_{s,t}}l(v)=​s≠v,t≠v​∑​​​C​s,t​​​​C​s,t​​(v)​​(s到t的最短路上经过v) 题解： 由于点数小于100，直接对于每个点SPFA完了之后暴力计算 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 220000 using namespace std; int tot,h[N],Next[N],w[N],v[N]; long long n,m,p[120],q[N],d[120][120],f[120][120],behind[N]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int l[120]; int spfa(long long d[],long long f[],int s){ for(int i=0;i&lt;=n;i++)d[i]=0x7fffffff; int head=0,tail=1; d[s]=0; p[s]=1; q[1]=s; p[s]=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[now]+w[i]&lt;d[v[i]]){ d[v[i]]=d[now]+w[i]; if(p[v[i]]==0){ q[++tail]=v[i]; p[v[i]]=1; } } } p[now]=0; } memset(l,0,sizeof(l)); for(int i=1;i&lt;=2*m;i++)if(d[v[behind[i]]]+w[i]==d[v[i]])l[v[i]]++; f[s]=1; q[1]=s; p[s]=1; head=0,tail=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[v[i]]==d[now]+w[i]){ f[v[i]]+=f[now]; l[v[i]]--; if(l[v[i]]==0)q[++tail]=v[i]; } } } } double cal(int x){ double ans=0; for(int i=1;i&lt;=n;i++){ if(x==i)continue; for(int j=1;j&lt;=n;j++){ if(x==j)continue; if(d[x][i]+d[x][j]&gt;d[i][j])continue; ans+=((double)f[x][i]+0.0)*f[x][j]/f[i][j]; } } return ans; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z);behind[tot]=tot+1; add(y,x,z);behind[tot]=tot-1; } for(int i=1;i&lt;=n;i++)spfa(d[i],f[i],i); for(int i=1;i&lt;=n;i++)printf(&quot;%.7lf\\n&quot;,cal(i)); }","path":"2018/06/27/NOI2007-社交网络/"},{"title":"BZOJ2042 陶陶的难题II","text":"题目大意： 树上每个节点有x,y,q,p四个值，每次查询一条链上两个节点iii和jjj使得yi+qjxi+pj\\frac{y_i+q_j}{x_i+p_j}​x​i​​+p​j​​​​y​i​​+q​j​​​​最大，输出这个最大值。 题解： 二分答案kkk,判定yi+qjxi+pj&gt;k\\frac{y_i+q_j}{x_i+p_j}&gt;k​x​i​​+p​j​​​​y​i​​+q​j​​​​&gt;k yi+qj−k(xi+pj)&gt;0y_i+q_j-k(x_i+p_j)&gt;0y​i​​+q​j​​−k(x​i​​+p​j​​)&gt;0 yi−kxi+qj−kpj&gt;0y_i-kx_i+q_j-kp_j&gt;0y​i​​−kx​i​​+q​j​​−kp​j​​&gt;0 既寻找yi−kxiy_i-kx_iy​i​​−kx​i​​和qj−kpjq_j-kp_jq​j​​−kp​j​​的最大值 两组的查询方法一样，将xix_ix​i​​设为横坐标，yiy_iy​i​​设为纵坐标，维护一条链上的凸包，做一条斜率为k的直线，然后三分取得最大值，链上的凸包维护用树链剖分实现，每个线段树的节点都用vector来储存凸包。 时间复杂度：O(nlog4n)O(n\\log^4n)O(nlog​4​​n) 二分答案一个logloglog，树链剖分两个logloglog，在凸包上三分一个logloglog（如果有n2n^2n​2​​的做法可能能直接碾过去）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define N 220000 #define eps (double)1e-10 using namespace std; int Next[N],v[N],h[N],siz[N],top[N],son[N],st[N],dep[N],f[N],ed[N],tot,cnt,n,m; struct illyasviel{ double x,y; }; double slope(illyasviel x,illyasviel y,illyasviel z){ return (y.y-x.y)*(z.x-x.x)&lt;(z.y-x.y)*(y.x-x.x); } struct node{ vector&lt;illyasviel&gt;a; int insert(illyasviel x){a.push_back(x);} int add(illyasviel x){ // if(fabs(x.x-a[]) if(a.size()==0){ a.push_back(x); return 0; } if(x.y&lt;=a[a.size()-1].y+eps)return 0; int o=a.size()-1; while(o&gt;=1&amp;&amp;slope(a[o-1],a[o],x)) a.pop_back(),o--; a.push_back(x); } double get(int x,double d){ return a[x].y-a[x].x*d; } double query(double d){ int l=0,r=a.size()-1; double ans=-100000000; // for(int i=0;i&lt;r;i++)printf(&quot;%.3lf %.3lf\\n&quot;,a[i].x,a[i].y); while(r-l&gt;3){ int ml=(l+r+l)/3,mr=(l+r+r)/3; if(get(ml,d)&lt;get(mr,d))l=ml; else r=mr; } for(int i=l;i&lt;=r;i++) ans=max(ans,get(i,d)); return ans; } }; node merge(node &amp;x,node &amp;y){ node ans; ans.a.clear(); int i=0,j=0; while(i&lt;x.a.size()||j&lt;y.a.size()){ if(i&lt;x.a.size()&amp;&amp;j&lt;y.a.size()){ if(x.a[i].x&lt;y.a[j].x){ ans.add(x.a[i]); i++; } else{ ans.add(y.a[j]); j++; } continue; } if(i&lt;x.a.size())ans.add(x.a[i]),i++; if(j&lt;y.a.size())ans.add(y.a[j]),j++; } return ans; } struct seg{ node a[N*4]; illyasviel s[N*4]; int build(int i,int l,int r){ if(l==r){ a[i].insert(s[ed[l]]); return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); a[i]=merge(a[i*2],a[i*2+1]); } double query(int i,int l,int r,int x,int y,double d){ if(x&lt;=l&amp;&amp;r&lt;=y)return a[i].query(d); int mid=(l+r)/2; double ans=-1000000000000.0; if(mid&gt;=x)ans=max(ans,query(i*2,l,mid,x,y,d)); if(mid&lt;y)ans=max(ans,query(i*2+1,mid+1,r,x,y,d)); return ans; } }s1,s2; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ siz[x]++; f[x]=fa; dep[x]=dep[fa]+1; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); siz[x]+=siz[v[i]]; if(siz[v[i]]&gt;siz[son[x]])son[x]=v[i]; } } int dfs1(int x,int fa){ st[x]=++cnt; if(son[x])top[son[x]]=top[x]; if(son[x])dfs1(son[x],x); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa||v[i]==son[x])continue; top[v[i]]=v[i]; dfs1(v[i],x); } } int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])y=f[top[y]]; else x=f[top[x]]; } return dep[x]&lt;dep[y]?x:y; } illyasviel query_illyasviel(int x,int y,double d){ illyasviel ans; ans.x=-100000000000000.0; ans.y=-100000000000000.0; if(dep[x]&lt;dep[y])swap(x,y); int r=st[x]; while(dep[top[x]]&gt;dep[y]){ ans.x=max(ans.x,s1.query(1,1,n,st[top[x]],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[top[x]],st[x],d)); // printf(&quot;%d %d\\n&quot;,st[top[x]],st[x]); x=f[top[x]]; } ans.x=max(ans.x,s1.query(1,1,n,st[y],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[y],st[x],d)); //printf(&quot;%d %d\\n&quot;,st[y],st[x]); return ans; } double check(double d,int x,int y){ int z=lca(x,y); illyasviel a,b; a=query_illyasviel(x,z,d); b=query_illyasviel(y,z,d); return max(a.x,b.x)+max(a.y,b.y); } double query(int x,int y){ double l=0.0,r=2000000.0; // printf(&quot;%.5lf\\n&quot;,check((double)4.85,x,y)); while(r-l&gt;1e-5){ double mid=(l+r)/2; if(check(mid,x,y)&gt;eps)l=mid; else r=mid; } return l+1e-6; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].y); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].y); for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs(1,0); top[1]=1; dfs1(1,0); for(int i=1;i&lt;=n;i++)ed[st[i]]=i; s1.build(1,1,n); s2.build(1,1,n); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%.5lf\\n&quot;,query(x,y)); } }","path":"2018/06/26/BZOJ2402-陶陶的难题II/"},{"title":"斜率优化","text":"作用： 将某些复杂度不对的dp方程降一个维度，譬如O（n^2）的dp方程，若其满足决策单调性，既可通过斜率优化对其进行降维打击，让它强行变成O（n）的。 #决策单调性： 若对于fif_if​i​​来说，选择k这个决策是最优的，那么对于fi+1f_{i+1}f​i+1​​到fnf_nf​n​​来说，选择k之前的决策不会比选择k更优。例如：若f具有决策单调性fi+1f_{i+1}f​i+1​​的决策一定是k或在k后面的决策。 【证明决策单调性】： 【数学归纳法】： 设fi=min(fj+ai−aj)f_i=min(f_j+a_i-a_j)f​i​​=min(f​j​​+a​i​​−a​j​​) 假设有两个决策j和k,k&gt;j且k优于j fk+ai−ak&lt;fj+ai−ajf_k+a_i-a_k&lt;f_j+a_i-a_jf​k​​+a​i​​−a​k​​&lt;f​j​​+a​i​​−a​j​​ fk−ak&lt;fj−ajf_k-a_k&lt;f_j-a_jf​k​​−a​k​​&lt;f​j​​−a​j​​ 那么对于fi+1f_{i+1}f​i+1​​来说选择kkk即fi+1=fk+ai+1−akf_{i+1}=f_k+a_{i+1}-a_kf​i+1​​=f​k​​+a​i+1​​−a​k​​ 而选择jjj的话即fi+1=fj+ai+1−ajf_{i+1}=f_j+a_{i+1}-a_jf​i+1​​=f​j​​+a​i+1​​−a​j​​ 因为第444行的式子，对于fi+1f_{i+1}f​i+1​​选择k明显比选择j更优，同理fi+2f_i+2f​i​​+2可通过fi+1f_{i+1}f​i+1​​得到，那么，可既可说这个dp方程具有决策单调性。 斜率优化： 举例子说明总是比较直观的，下面我们来看一道例题。 【题目】: 现在我们有一个序列aaa，我们能把序列aaa切成若干段，对于在iii和jjj被断开的一段序列，既ai..ja_{i..j}a​i..j​​，我们可以得到一个分数∑k=ijak\\sum_{k=i}^j a_k∑​k=i​j​​a​k​​。我们在i位置切割一次，就会得到cic_ic​i​​的分数。那么对于整个序列a，我们希望它的总分最小，求这个分数和。 【n2n^2n​2​​做法】: 显然，我们能得到一个效率为n2n^2n​2​​的dp方程 我们先设 sumk=∑i=1kaisum_k=\\sum_{i=1}^ka_i sum​k​​=​i=1​∑​k​​a​i​​ fi=min(fj+(simi−sumj)2+ci)f_i=min(f_j+(sim_i-sum_j)^2+c_i) f​i​​=min(f​j​​+(sim​i​​−sum​j​​)​2​​+c​i​​) 若n≤105n\\leq10^5n≤10​5​​那么这个复杂度不能令人满意，我们就要接着对他进行一些处理。 【证明决策单调性】 若k&gt;jk&gt; jk&gt;j且kkk优于jjj fj+(sumi−sumj)2+ci&gt;fk+(sumi−sumk)2+cif_j+(sum_i-sum_j)^2+c_i&gt;f_k+(sum_i-sum_k)^2+c_i f​j​​+(sum​i​​−sum​j​​)​2​​+c​i​​&gt;f​k​​+(sum​i​​−sum​k​​)​2​​+c​i​​ fj+sumi2−2×sumi×sumj+sumj2+ci&gt;fk+sumi2−2×sumi×sumk+sumk2+cif_j+sum_i^2-2\\times sum_i\\times sum_j+sum_j^2+c_i&gt;f_k+sum_i^2-2\\times sum_i\\times sum_k+sum_k^2+c_i f​j​​+sum​i​2​​−2×sum​i​​×sum​j​​+sum​j​2​​+c​i​​&gt;f​k​​+sum​i​2​​−2×sum​i​​×sum​k​​+sum​k​2​​+c​i​​ fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 那么对于fi+1f_{i+1}f​i+1​​来说: 选择j为决策既：fi+1=fj+(sumi+1−sumj)2+ci+1f_{i+1}=f_j+(sum_{i+1}-sum_j)^2+c_{i+1}f​i+1​​=f​j​​+(sum​i+1​​−sum​j​​)​2​​+c​i+1​​ 选择k为决策既：fi+1=fk+(sumi+1−sumk)2+ci+1f_{i+1}=f_k+(sum_{i+1}-sum_k)^2+c_{i+1}f​i+1​​=f​k​​+(sum​i+1​​−sum​k​​)​2​​+c​i+1​​ 从上面的式子可以得到选择k优于选择j（不信的话可以自己展开） 那么可以证明这个dp方程式具有决策单调性的。 【推导斜率式】 fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 从这条式子继续 fj−fk+sumj2−sumk2&gt;2×sumi∗(sumj−sumk)f_j-f_k+sum_j^2-sum_k^2&gt;2\\times sum_i*(sum_j-sum_k) f​j​​−f​k​​+sum​j​2​​−sum​k​2​​&gt;2×sum​i​​∗(sum​j​​−sum​k​​) fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i ​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​ 根据这条式子的定义，我们可以得到，对于k&gt;jk&gt;jk&gt;j，只有在满足上面式子的情况下才会k比j优 我们把(fj+sumj2,sumj)(f_j+sum_j^2,sum_j)(f​j​​+sum​j​2​​,sum​j​​)和(fk+sumk2,sumk)(f_k+sum_k^2,sum_k)(f​k​​+sum​k​2​​,sum​k​​)分别看做坐标系上面的点，那么小于号左边的式子的含义恰好是这两个点之间的斜率。 现在我们假设找到了一个点(x,y)对于fif_if​i​​最优。我们在x点上画一条斜率为2∗sumi2*sum_i2∗sum​i​​的斜线，那么，对于其他所有点，都必须在这条斜线上方。 证明：若(a,b)(a,b)(a,b)在斜线下方，且a&lt;xa&lt;xa&lt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会大于2×sumi2\\times sum_i2×sum​i​​并且a&lt;xa&lt;xa&lt;x，那么(x,y)则不是最优点。若(a,b)在斜线下方，且a&gt;xa&gt;xa&gt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会小于2×sumi2\\times sum_i2×sum​i​​并且a&gt;xa&gt;xa&gt;x，那么(x,y)则不是最优点。 换句话说，对于fif_if​i​​来说，最优解x是斜率k=2∗sumik=2*sum_ik=2∗sum​i​​从下往上扫扫到点集里最优的那个点。 显然，我们可以得到一个很显然的结论，那就是这个最优解x在下凸壳上。那么我们可以通过一个队列来维护凸包，并且根据决策单调性，还有fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​这条斜率式，我们可以每次比对下凸壳上相邻的两个点（也就是队首元素），若队列中第二个元素比队首元素优，那么我们可以删除队首元素（决策单调性，队首元素再也用不到）。 我们注意到，对于点i来说，他的横坐标是sumisum_isum​i​​,因为sumisum_isum​i​​是前缀和，是递增的，所以加入的点的横坐标也是递增的，那么对于每个点，我们只要把它加入维护凸包的那个队列就好了。 【某些不得不说的东西】： 最后我们推出来的式子一般都是长这样： x与j和k有关，y与j和k有关并且递增 xy\\frac{x}{y}​y​​x​​&lt;或&gt;只与i有关并且递增的常数 如果右边的与i有关的常数不是递增的，那意味着我们要扫的答案的斜率不是递增的，那么决策单调性就会消失，我们就要用平衡树或者三分去维护。所以一般，正常，好写的斜率优化最后推出来的式子一般都形如上面那条√","path":"2018/06/24/斜率优化/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","path":"2018/06/23/hello-world/"}]}