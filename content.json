{"pages":[],"posts":[{"title":"mit6.S081 lab1","text":"Lab: Xv6 and Unix utilities sleep (easy) #include &quot;kernel/types.h&quot; #include &quot;kernel/stat.h&quot; #include &quot;user/user.h&quot; int main(int argc,char *argv[]){ // printf(&quot;%d\\n&quot;,argc); // for(int i=0;i&lt;argc;i++)printf(&quot;%s\\n&quot;,argv[i]); if(argc!=2){ printf(&quot;少了个描述时间的数字\\n&quot;); }else{ sleep(atoi(argv[1])); } exit(0); } pingpong (easy) #include &quot;kernel/types.h&quot; #include &quot;user/user.h&quot; int main(){ int pid; int p[2]; pipe(p); pid=fork(); if(pid==0){ printf(&quot;%d: received ping\\n&quot;,getpid()); close(p[0]); write(p[1],&quot;ping-pong&quot;,9); }else{ close(p[1]); char a[10]; read(p[0],a,9); // printf(&quot;%s\\n&quot;,a); printf(&quot;%d: received pong\\n&quot;,getpid()); } exit(0); } primes (moderate)/(hard) #include &quot;kernel/types.h&quot; find (moderate)#include &quot;user/user.h&quot; int flag=0,prime=0; int from[2],to[2],p[2]; int receive(int x); int transport(int x); int receive(int x){ if(x==-1)exit(0); printf(&quot;prime %d\\n&quot;,x); flag=1; prime=x; pipe(p); int pid=fork(); if(pid==0){ flag=0; from[0]=p[0]; from[1]=p[1]; close(from[1]); while(x!=-1){ read(from[0],&amp;x,4); transport(x); } close(from[0]); wait(0); exit(0); }else{ to[0]=p[0]; to[1]=p[1]; close(to[0]); } return 0; } int transport(int x){ if(flag==0)receive(x); else{ if(x%prime!=0||prime==0)write(to[1],&amp;x,4); } return 0; } int main(){ for(int i=2;i&lt;=35;i++)transport(i); transport(-1); close(to[1]); wait(0); exit(0); } find (moderate) #include &quot;kernel/types.h&quot; #include &quot;kernel/stat.h&quot; #include &quot;user/user.h&quot; #include &quot;kernel/fs.h&quot; char* fmtname(char *path){ static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--); p++; // Return blank-padded name. if(strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf+strlen(p), 0, DIRSIZ-strlen(p)); return buf; } void find(char *path,char *name){ char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; } if(fstat(fd, &amp;st) &lt; 0){ fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0){ printf(&quot;ls: cannot stat %s\\n&quot;, buf); continue; } if(st.type==2){ if(strcmp(fmtname(buf),name)==0)printf(&quot;%s\\n&quot;,buf); } if(st.type==1){ if(strcmp(fmtname(buf),&quot;.&quot;)!=0&amp;&amp;strcmp(fmtname(buf),&quot;..&quot;)!=0)find(buf,name); } // printf(&quot;%s %d %d %d\\n&quot;, buf, st.type, st.ino, st.size); } close(fd); } int main(int argc, char *argv[]){ find(argv[1],argv[2]); exit(0); } xargs (moderate) #include &quot;kernel/types.h&quot; #include &quot;user/user.h&quot; char a[120][120]; char *b[120]; int c[120]; int row,column; char tmp; int solve(char s[],int argc,char *argv[]){ int n=strlen(s); int A=0; for(int i=1;i&lt;argc;i++){ b[A]=argv[i]; A++; } b[A]=&amp;s[0]; A++; for(int i=0;i&lt;n;i++){ if(s[i]==' '){ s[i]=0; b[A]=&amp;s[i+1]; A++; } } b[A]=0; //for(int i=0;i&lt;A;i++)printf(&quot;AA::%s\\n&quot;,b[i]); exec(argv[1],b); exit(0); } int main(int argc,char *argv[]){ while(read(0,&amp;tmp,1)){ if(tmp=='\\n'){ row++; column=0; // a[row]=new char[120]; continue; } a[row][column++]=tmp; } for(int i=0;i&lt;row;i++){ int pid=fork(); if(pid==0){ solve(a[i],argc,argv); exit(0); } } // for(int i=0;i&lt;row;i++)wait(0); while(wait(0)!=-1); exit(0); }","path":"2021/09/09/mit6.S081 lab1/"},{"title":"mit6.S081 lab2","text":"Lab syscall: System calls System call tracing (moderate) syscall流程： 调用system call(用户态)-&gt;进入syscall.c作为跳板(内核态)-&gt;跳入具体syscall函数(内核态) 内核态中存在myproc()可以返回一个struct proc中贮存这调用system call的进程的信息。 Sysinfo (moderate) kernel/kalloc.c 内存分配策略： 4kb为一页 空闲内存的页头存在一个指针指向下一个空闲内存的页头，将内存串起来。 kernel/proc.c 进程分配策略： 累计进程号+1（保证了所有线程pid独立） 遍历所有进程： 找到第一个空闲的讲起返回 copyout 用户态和内核态用的内存地址都是独立的 需要用pagetable和copyoout来获取真实的地址来传入传出数据","path":"2021/09/09/mit6.S081 lab2/"}]}