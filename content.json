{"pages":[],"posts":[{"title":"mit6.S081 lab1","text":"Lab: Xv6 and Unix utilities sleep (easy) #include &quot;kernel/types.h&quot; #include &quot;kernel/stat.h&quot; #include &quot;user/user.h&quot; int main(int argc,char *argv[]){ // printf(&quot;%d\\n&quot;,argc); // for(int i=0;i&lt;argc;i++)printf(&quot;%s\\n&quot;,argv[i]); if(argc!=2){ printf(&quot;少了个描述时间的数字\\n&quot;); }else{ sleep(atoi(argv[1])); } exit(0); } pingpong (easy) #include &quot;kernel/types.h&quot; #include &quot;user/user.h&quot; int main(){ int pid; int p[2]; pipe(p); pid=fork(); if(pid==0){ printf(&quot;%d: received ping\\n&quot;,getpid()); close(p[0]); write(p[1],&quot;ping-pong&quot;,9); }else{ close(p[1]); char a[10]; read(p[0],a,9); // printf(&quot;%s\\n&quot;,a); printf(&quot;%d: received pong\\n&quot;,getpid()); } exit(0); } primes (moderate)/(hard) #include &quot;kernel/types.h&quot; find (moderate)#include &quot;user/user.h&quot; int flag=0,prime=0; int from[2],to[2],p[2]; int receive(int x); int transport(int x); int receive(int x){ if(x==-1)exit(0); printf(&quot;prime %d\\n&quot;,x); flag=1; prime=x; pipe(p); int pid=fork(); if(pid==0){ flag=0; from[0]=p[0]; from[1]=p[1]; close(from[1]); while(x!=-1){ read(from[0],&amp;x,4); transport(x); } close(from[0]); wait(0); exit(0); }else{ to[0]=p[0]; to[1]=p[1]; close(to[0]); } return 0; } int transport(int x){ if(flag==0)receive(x); else{ if(x%prime!=0||prime==0)write(to[1],&amp;x,4); } return 0; } int main(){ for(int i=2;i&lt;=35;i++)transport(i); transport(-1); close(to[1]); wait(0); exit(0); } find (moderate) #include &quot;kernel/types.h&quot; #include &quot;kernel/stat.h&quot; #include &quot;user/user.h&quot; #include &quot;kernel/fs.h&quot; char* fmtname(char *path){ static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--); p++; // Return blank-padded name. if(strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf+strlen(p), 0, DIRSIZ-strlen(p)); return buf; } void find(char *path,char *name){ char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; } if(fstat(fd, &amp;st) &lt; 0){ fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0){ printf(&quot;ls: cannot stat %s\\n&quot;, buf); continue; } if(st.type==2){ if(strcmp(fmtname(buf),name)==0)printf(&quot;%s\\n&quot;,buf); } if(st.type==1){ if(strcmp(fmtname(buf),&quot;.&quot;)!=0&amp;&amp;strcmp(fmtname(buf),&quot;..&quot;)!=0)find(buf,name); } // printf(&quot;%s %d %d %d\\n&quot;, buf, st.type, st.ino, st.size); } close(fd); } int main(int argc, char *argv[]){ find(argv[1],argv[2]); exit(0); } xargs (moderate) #include &quot;kernel/types.h&quot; #include &quot;user/user.h&quot; char a[120][120]; char *b[120]; int c[120]; int row,column; char tmp; int solve(char s[],int argc,char *argv[]){ int n=strlen(s); int A=0; for(int i=1;i&lt;argc;i++){ b[A]=argv[i]; A++; } b[A]=&amp;s[0]; A++; for(int i=0;i&lt;n;i++){ if(s[i]==' '){ s[i]=0; b[A]=&amp;s[i+1]; A++; } } b[A]=0; //for(int i=0;i&lt;A;i++)printf(&quot;AA::%s\\n&quot;,b[i]); exec(argv[1],b); exit(0); } int main(int argc,char *argv[]){ while(read(0,&amp;tmp,1)){ if(tmp=='\\n'){ row++; column=0; // a[row]=new char[120]; continue; } a[row][column++]=tmp; } for(int i=0;i&lt;row;i++){ int pid=fork(); if(pid==0){ solve(a[i],argc,argv); exit(0); } } // for(int i=0;i&lt;row;i++)wait(0); while(wait(0)!=-1); exit(0); }","path":"2021/09/09/lab1/"},{"title":"【Array Poisonous Suffix Problem】","text":"题目大意： Are you going to solve poisonous problems? - Thanks a lot for today’s poisonous problems. What are you doing at the end of the world? Are you busy? Will you save us? Ithea and Chtholly want to play a game in order to determine who will solve poisonous problems. - Willem… Lakhesh loves to make poisonous problems, so Nephren helps her run a cinema. We may call it No. 68 Cinema. - I… I survived. 如题目背景所述，这是一道 PSP（Poisonous String Problem，毒瘤字符串题）。 对于一个正整数k，若任何一个 $1∼n $的排列均是某个字符集大小不超过k的字符串的后缀排名数组（后缀排名数组即后缀数组的逆排列，如果你不知道什么是后缀数组，可以自行搜索或参考Wiki 对后缀数组的介绍），则称k对于n是毒瘤的。给定k，你需要找到一个最小的正整数n使k对于n不是毒瘤的，并且你需要给出1∼n的一个排列，其不是任何一个字符集大小不超过k的字符串的后缀排名数组。如果有多个排列，输出字典序最小的，如果不存在这样的n和排列，输出 213。 一句话题意： 给出一个k，k为字符集大小，求出最小的n使得存在一个排列使得没有一个长度为n的字符串的sa数组是这个排列。 前情提要： saisa_isa​i​​表示的是排名为i的后缀的起始位置。 题解： n最小为k+1，因为k个字符的话每个字符不同可使sa达到全排列。 我们设g(x)g(x)g(x)为字符串Sx...nS_{x...n}S​x...n​​,我们现在考虑一个排列a，使得g(a1)&lt;g(a2)&lt;g(a3)&lt;...&lt;g(an)g(a_1)&lt;g(a_2)&lt;g(a_3)&lt;...&lt;g(a_n)g(a​1​​)&lt;g(a​2​​)&lt;g(a​3​​)&lt;...&lt;g(a​n​​)。 那么，我们要达成的要求就是使得Sa1&lt;Sa2&lt;Sa3&lt;...&lt;SanS_{a_1}&lt;S_{a_2}&lt;S_{a_3}&lt;...&lt;S_{a_n}S​a​1​​​​&lt;S​a​2​​​​&lt;S​a​3​​​​&lt;...&lt;S​a​n​​​​(字符集为n-1,所以要有n个严格小于的关系)。 考虑g(ai)&lt;g(ai+1)g(a_i)&lt;g(a_{i+1})g(a​i​​)&lt;g(a​i+1​​)，我们要使Sai&lt;Sai+1S_{a_i}&lt;S_{a_{i+1}}S​a​i​​​​&lt;S​a​i+1​​​​，那么必须要使g(ai+1)&gt;g(ai+1+1)g(a_i+1)&gt;g(a_{i+1}+1)g(a​i​​+1)&gt;g(a​i+1​​+1)(因为g(x)g(x)g(x)相当于是SxS_{x}S​x​​与g(x+1)g(x+1)g(x+1)拼凑出来的字符串，而为了严格小于，字典序小的第二位开始的后缀必须要大于字典序大的)。 那么便有： g(n+1)&lt;g(a1)&lt;g(a2)&lt;g(a3)&lt;...&lt;g(an)g(n+1)&lt;g(a_1)&lt;g(a_2)&lt;g(a_3)&lt;...&lt;g(a_n)g(n+1)&lt;g(a​1​​)&lt;g(a​2​​)&lt;g(a​3​​)&lt;...&lt;g(a​n​​)(g(n+1)g(n+1)g(n+1)为空串)（g里的值域为1到n+1） g(an+1)&lt;g(an−1+1)&lt;g(an−2+1)&lt;...&lt;g(a1+1)g(a_n+1)&lt;g(a_{n-1}+1)&lt;g(a_{n-2}+1)&lt;...&lt;g(a_1+1)g(a​n​​+1)&lt;g(a​n−1​​+1)&lt;g(a​n−2​​+1)&lt;...&lt;g(a​1​​+1)（g里的值域为2到n+1） 上面与下面一一对应（除了当上方g中的ax=1a_{x}=1a​x​​=1时）（也就是上面比下面多一项，除了这一项，其他都是一一对应的） an+1=n+1a_n+1=n+1a​n​​+1=n+1（上方的第一项已经确定n+1≠1n+1\\neq1n+1≠1） ana_na​n​​确定后，a1a_1a​1​​又可以确定，这样递归确定下去，知道axa_xa​x​​等于1了，就可以推出。 可以发现，满足要求的排列是唯一的。并且，这个求出来的，是sa的逆数组rk数组，再返回去，就可以O(n)O(n)O(n)得到答案。 也可以归纳一下变成下面代码的形式。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int a[120000],n,tot; int main(){ int n; scanf(&quot;%d&quot;,&amp;n); n++; printf(&quot;%d\\n&quot;,n); if(n%2){ for(int i=n-1;i;i-=2)a[i]=++tot; for(int i=1;i&lt;=n;i+=2)a[i]=++tot; }else{ for(int i=n-1;i&gt;0;i-=2)a[i]=++tot; for(int i=2;i&lt;=n;i+=2)a[i]=++tot; } for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]); } 题目链接：「LibreOJ β Round #7」Array Poisonous Suffix Problem","path":"2018/07/25/「LibreOJ-β-Round-7」Array-Poisonous-Suffix-Problem/"}]}