{"pages":[{"title":"tags","text":"","path":"tags/index.html"},{"title":"“categories”","text":"","path":"categories/index.html"}],"posts":[{"title":"mit6.S081 lab2","text":"Lab syscall: System calls System call tracing (moderate) syscall流程： 调用system call(用户态)-&gt;进入syscall.c作为跳板(内核态)-&gt;跳入具体syscall函数(内核态) 内核态中存在myproc()可以返回一个struct proc中贮存这调用system call的进程的信息。 Sysinfo (moderate) kernel/kalloc.c 内存分配策略： 4kb为一页 空闲内存的页头存在一个指针指向下一个空闲内存的页头，将内存串起来。 kernel/proc.c 进程分配策略： 累计进程号+1（保证了所有线程pid独立） 遍历所有进程： 找到第一个空闲的讲起返回 copyout 用户态和内核态用的内存地址都是独立的 需要用pagetable和copyoout来获取真实的地址来传入传出数据","path":"2021/09/09/mit6.S081 lab2/"},{"title":"mit6.S081 lab1","text":"Lab: Xv6 and Unix utilities sleep (easy) 12345678910111213#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"int main(int argc,char *argv[])&#123;// printf(\"%d\\n\",argc);// for(int i=0;i&lt;argc;i++)printf(\"%s\\n\",argv[i]); if(argc!=2)&#123; printf(\"少了个描述时间的数字\\n\"); &#125;else&#123; sleep(atoi(argv[1])); &#125; exit(0);&#125; pingpong (easy) 1234567891011121314151617181920#include \"kernel/types.h\"#include \"user/user.h\"int main()&#123; int pid; int p[2]; pipe(p); pid=fork(); if(pid==0)&#123; printf(\"%d: received ping\\n\",getpid()); close(p[0]); write(p[1],\"ping-pong\",9); &#125;else&#123; close(p[1]); char a[10]; read(p[0],a,9); // printf(\"%s\\n\",a); printf(\"%d: received pong\\n\",getpid()); &#125; exit(0);&#125; primes (moderate)/(hard) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"kernel/types.h\"find (moderate)#include \"user/user.h\"int flag=0,prime=0;int from[2],to[2],p[2];int receive(int x);int transport(int x);int receive(int x)&#123; if(x==-1)exit(0); printf(\"prime %d\\n\",x); flag=1; prime=x; pipe(p); int pid=fork(); if(pid==0)&#123; flag=0; from[0]=p[0]; from[1]=p[1]; close(from[1]); while(x!=-1)&#123; read(from[0],&amp;x,4); transport(x); &#125; close(from[0]); wait(0); exit(0); &#125;else&#123; to[0]=p[0]; to[1]=p[1]; close(to[0]); &#125; return 0;&#125;int transport(int x)&#123; if(flag==0)receive(x); else&#123; if(x%prime!=0||prime==0)write(to[1],&amp;x,4); &#125; return 0;&#125;int main()&#123; for(int i=2;i&lt;=35;i++)transport(i); transport(-1); close(to[1]); wait(0); exit(0);&#125; find (moderate) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\"char* fmtname(char *path)&#123; static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--); p++; // Return blank-padded name. if(strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf+strlen(p), 0, DIRSIZ-strlen(p)); return buf;&#125;void find(char *path,char *name)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) &lt; 0)&#123; fprintf(2, \"find: cannot open %s\\n\", path); return; &#125; if(fstat(fd, &amp;st) &lt; 0)&#123; fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; &#125; strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123; if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0)&#123; printf(\"ls: cannot stat %s\\n\", buf); continue; &#125; if(st.type==2)&#123; if(strcmp(fmtname(buf),name)==0)printf(\"%s\\n\",buf); &#125; if(st.type==1)&#123; if(strcmp(fmtname(buf),\".\")!=0&amp;&amp;strcmp(fmtname(buf),\"..\")!=0)find(buf,name); &#125; // printf(\"%s %d %d %d\\n\", buf, st.type, st.ino, st.size); &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; find(argv[1],argv[2]); exit(0);&#125; xargs (moderate) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"kernel/types.h\"#include \"user/user.h\"char a[120][120];char *b[120];int c[120];int row,column;char tmp;int solve(char s[],int argc,char *argv[])&#123; int n=strlen(s); int A=0; for(int i=1;i&lt;argc;i++)&#123; b[A]=argv[i]; A++; &#125; b[A]=&amp;s[0]; A++; for(int i=0;i&lt;n;i++)&#123; if(s[i]==' ')&#123; s[i]=0; b[A]=&amp;s[i+1]; A++; &#125; &#125; b[A]=0; //for(int i=0;i&lt;A;i++)printf(\"AA::%s\\n\",b[i]); exec(argv[1],b); exit(0);&#125;int main(int argc,char *argv[])&#123; while(read(0,&amp;tmp,1))&#123; if(tmp=='\\n')&#123; row++; column=0; // a[row]=new char[120]; continue; &#125; a[row][column++]=tmp; &#125; for(int i=0;i&lt;row;i++)&#123; int pid=fork(); if(pid==0)&#123; solve(a[i],argc,argv); exit(0); &#125; &#125;// for(int i=0;i&lt;row;i++)wait(0); while(wait(0)!=-1); exit(0);&#125;","path":"2021/09/08/mit6.S081 lab1/"}]}